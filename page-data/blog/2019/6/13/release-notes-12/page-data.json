{"componentChunkName":"component---src-views-blog-single-index-tsx","path":"/blog/2019/6/13/release-notes-12","webpackCompilationHash":"aefb7e842b40c338951f","result":{"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/blog/2019/6/13/release-notes-12","post":{"id":"8563db8c-49cd-5fa4-ab83-eafbcc5b04e8","rawMarkdownBody":"\nIt's about time to sail our ship to Istanbul and see all of the new features and tweaks that come with the 1.2 release. This time around we focused on streamlining the installation flow, providing a simpler way of testing lambda functions, giving more power and flexibility to Kyma Eventing, migrating to a new version of Istio, and providing even more useful documentation.\n\n<!-- overview -->\n\nThe highlights of Kyma 1.2 Istanbul include:\n\n- [Streamlined installation](#installation) - We enabled platform-agnostic local installation with the Kyma CLI, enabled Kyma installation through GCP Marketplace, and simplified all cluster installation flows.\n- [Testing lambda functions in the UI](#testing-lambda-functions-in-the-ui) - We added an option to test lambda functions through the Console UI.\n- [Migration to Istio 1.1.6](#service-mesh) - We migrated to a new, more secure and stable version of Istio.\n- [Migration to Istio in the Application Connector](#migration-to-istio) - We moved from NGINX Ingress to Istio in the Application Connector.\n- [Configuration for using different messaging middleware](#choose-and-configure-a-custom-messaging-middleware) - We added configuration that allows using different messaging middleware in Kyma Eventing.\n\nSee the overview of all changes in this release:\n\n- [Application Connector](#application-connector) - Migration to Istio, support for custom headers and query parameters in authentication requests\n- [Console](#console) - Testing lambda functions through the UI, more configuration options available at the moment of Namespace creation\n- [Installation](#installation) - Local installation with Kyma CLI, Kyma available trough GCP Marketplace, streamlined cluster installation flows\n- [Documentation](#documentation) - New configuration, troubleshooting, and Headless CMS metadata documents, tutorial for customizing the Documentation view in the Console UI, testing bundle with sample documentation\n- [Eventing](#eventing) - Choosing and configuring a custom messaging middleware, sending custom metadata with published Events, an example for triggering microservices with Events\n- [Observability](#observability) - Early version of Kiali added to Istio\n- [Service Mesh](#service-mesh) - Istio update to version 1.1.6\n\nRead about a known issue for [Observability](#known-issues).\n\n> **CAUTION:** Before you upgrade to Kyma 1.2, read the [Migration Guide](https://github.com/kyma-project/kyma/blob/release-1.2/docs/migration-guides/1.1-1.2.md) which describes necessary manual actions required by the Event Bus, the Asset Store, and the Application Connector.\n\n---\n\n## Application Connector\n\n### Migration to Istio\n\nFrom the very beginning of the Kyma project, the Application Connector has been exposed using the NGINX Ingress. After the recent changes in Istio 1.x which included support for client certificates, we decided to migrate to Istio as did the rest of Kyma components. We are proud to announce that the migration is complete and we are already benefiting from a number of advantages including easier maintenance and a smaller number of components in the implementation.\n\nRead [this](/docs/1.2/components/application-connector/#architecture-architecture) document to learn more about the role Istio plays in the Application Connector.\n\n### Custom headers and query parameters in authentication requests\n\nTo facilitate the integration of APIs that require sending additional headers and query parameters with every request to an external system, we allow the developers to provide a custom list of the headers and query parameters when registering an API in the Application Registry. The Proxy service reads this configuration and enriches each call from an API to an external service with the required items.\n\nRead [this](/docs/1.2/components/application-connector/#tutorials-register-a-secured-api-specify-custom-headers-and-query-parameters-for-authentication-requests) document to learn more.\n\n## Console\n\n### Testing lambda functions in the UI\n\nNow you can test your lambda functions directly in the Console UI. Use any of the Event samples available in your Namespace or any custom payload to dryâ€“run a function before connecting it to your live system's business events.\n\n### More configuration options at the moment of Namespace creation\n\nUsers can now configure more of the important Namespace options when they create it using the UI. The available options include setting memory consumption limits and choosing whether Istio should handle all of the communication between Pods in the Namespace.\n\n## Installation\n\n### Kyma available on GCP Marketplace\n\nDeploying on GKE is now easier than ever as you can get a fully functional Kyma deployment with `http://xip.io/` straight from the GCP Marketplace. Follow [this link](https://console.cloud.google.com/marketplace/details/sap-public/kyma) to find Kyma on the Marketplace, read [this](/docs/1.2/root/kyma/#installation-install-kyma-on-a-cluster) document to get detailed installation instructions, and watch [this video](https://www.youtube.com/watch?v=hxVhQqI1B5A) for a detailed walkthrough. Enjoy!\n\n### Platform-agnostic local deployments with Kyma CLI\n\nOur very own [Kyma CLI](https://github.com/kyma-project/cli) graduated from the Incubator and became an integral part of Kyma with the 1.2 release. From now on you can use simple `kyma` commands to easily deploy Kyma on your local machine, no matter what OS you're running - all you have to do is install our proprietary CLI tool. The local installation flow is now updated to use the CLI and we are retiring the old installation approach that used custom scripts.\n\nTo experience the convenience the Kyma CLI brings to the table, follow [our documentation](/docs/1.2/root/kyma/#installation-install-kyma-locally) to install Kyma on your machine.\n\n### Simpler cluster installation\n\nThe existing cluster installation flows were significantly simplified. The `sed` commands and the cluster configuration template file are now gone in favor of a set of `kubectl` calls. Now you simply set up your cluster, apply the desired configuration with `kubectl`, and wait for the magic to happen. For more details, see the [installation documentation](/docs/1.2/root/kyma/#installation-installation).\n\n## Documentation\n\n### Configuration documents for components\n\nAfter preparing a set of generic configuration documents in the last release, this time around we focused on specific Kyma components. The idea was to create configuration documents that list all configurable parameters from the `values.yaml` file of each of the components' charts and sub-charts that you can configure with overrides. Not all components have their **Configuration** documents ready, but you can expect full coverage in the near future.\n\n### Troubleshooting guides\n\nAs we interact with the community, we take note of recurring issues and misunderstandings that affect different components. We decide to gather these cases under the **Troubleshooting** documentation type to help the users deal with the most common issues easily. The troubleshooting documents are now available for the [Service Mesh](/docs/1.2/components/service-mesh/#troubleshooting-troubleshooting) and the general [Kyma](/docs/1.2/root/kyma/#troubleshooting-troubleshooting-overview) topic.\n\n### Markdown documents in Headless CMS\n\nIf you've ever had any doubts regarding what the structure of a Markdown document processed by Headless CMS should look like, we come with a solution. See the [document](/docs/1.2/components/headless-cms/#details-markdown-documents) describing the required metadata and content of a Markdown file.\n\n### How to modify the Documentation view in the Console UI\n\nWe prepared a tutorial that shows how to adjust the Documentation view in the Console UI. Based on it, you create a new Prometheus documentation section that contains Concepts and Guides topics and a set of Markdown subdocuments. [Try it](/docs/1.2/components/headless-cms/#tutorial-add-new-documents-to-the-documentation-view-in-the-console-ui) on your own.\n\n### Testing bundle with sample documentation\n\nThe testing bundle is now enriched with [sample documentation](https://github.com/kyma-project/addons/tree/master/addons/testing-0.0.1/docs). There are examples of Markdown documents together with OpenAPI and AsyncAPI specifications. See the testing bundle for details on how different document types render in the Console UI.  \n\n\n## Eventing\n\n### Choose and configure a custom messaging middleware\n\nOut of the box, Kyma comes with NATS Streaming as the default messaging middleware. With this release, we're giving you the tools to choose your own messaging middleware that best fits your needs from the usage, volume, and costs perspective. The only requirement is that the middleware must have Knative eventing-based [ClusterChannelProvisioner](https://knative.dev/docs/eventing/channels/) available. Compatible solutions include Google PubSub, Kafka, and NATSS.\n\n### Sending custom metadata with published Events\n\nThe applications sending Events to Kyma can now send additional context or metadata by sending headers with the `ce-` prefix, for example, `ce-correlation-id`. These headers are delivered to the lambda function.\n\n### Example for triggering microservices with Events\n\nWe prepared a self-contained example that shows how to configure an Event trigger for a microservice deployed in Kyma. This is extremely useful for applications written in Java which want to use Events as a trigger.\n\n\n## Observability\n\n### Early integration of Kiali\n\nEarly integration of Kiali is available as part of Istio. To enable Kiali, ensure that the monitoring module is installed and set the **kiali.enabled** parameter to `true`. The Kiali UI will be accessible under the `kiali` subdomain. The early integration is based on static user security. To learn how to get the Kiali UI password, see [this](https://github.com/kyma-project/kyma/tree/master/resources/istio) document.\n\n### Known issues\n\nKiali is not accessible after installation when enabled as part of the Installer configuration. It should be accessible on Minikube at `https://kiali.kyma.local`.\nTo access it this way, use the workaround for now and add the `kiali` prefix to the **hosts** attribute in the `kiali-virtualservice` resource:\n```\nkubectl -n istio-system edit virtualservices kiali-virtualservice\n```\n```\nhosts:\n- kiali.kyma.local\n```\n\n## Service Mesh\n\n### Istio updated to 1.1.6\n\nThe new release comes with Istio updated to 1.1.6. Previously Kyma used version 1.1.0, but due to a security issue and problems with the Ingress Gateway, we moved to a newer version. The update makes the Service Mesh more secure and stable - the Ingress Gateway issues seen in the previous version that caused port configurations not being applied properly are now resolved.\n","excerpt":"It's about time to sail our ship to Istanbul and see all of the new features and tweaks that come with the 1.2 release. This time around we focused on streamlining the installation flow, providing a simpler way of testing lambda functions, giving more power and flexibility to Kyma Eventing, migrating to a new version of Istio, and providing even more useful documentation.","fields":{"slug":"/blog/2019/6/13/release-notes-12","assetsPath":"/assets/blog-posts/2019-06-13-release-notes-1.2/","date":"June 13, 2019","postInfo":{"fileName":"release-notes-12","year":2019,"month":6,"day":13}},"frontmatter":{"title":"Kyma 1.2 Istanbul","author":{"name":"Tomasz Papiernik, Technical Writer @Kyma"},"tags":["release-notes"],"type":"release","releaseTag":"1.2.0","redirectFrom":["/blog/release-notes-12"]}},"assetsPath":"/assets/blog-posts/2019-06-13-release-notes-1.2/","previous":{"id":"f2c2aac7-9f39-540d-b83e-81cc64f75fb0","rawMarkdownBody":"\nJust as we initially promised, the developers are working hard to deliver new features and improvements every four weeks. Our last release is already available for 3 weeks, which means that the next Kyma version will be available in about a week. This time around, the release gets its codename from a city with an incredibly rich history, one that bridges the gap (literally!) between the East and the West. Kyma 1.2 Istanbul has a very rich history of improvements and new features and continues to aid the users in bridging the gap between different pieces of software. What's in store for the 1.2 release? \n<!-- overview -->\n\nFirst, let's have a look at the new features. We received a lot of feedback about writing and testing lambdas in the Console UI. It is quite easy to copy and paste the code from the examples over to the UI, the developers complained that testing their own code requires more effort than that. They wanted an easy way to check how their functions work with the message data they will get from the triggering event. To help the developers check that, we will introduce a single UI view which allows to prepare a sample event payload based on the message schema, send it directly to a lambda function, and check the result. This new feature should significantly speed up the developers' feedback loop.\n\nAnother new feature we're working on is the possibility to make only the selected Service Classes of an Application registered in Kyma bindable. Let's say that your Application exposes many APIs with different permission levels, such as a view-only API and an admin API. With the new feature, the system administrator can decide what services and APIs are available in a given Namespace.\n\nInstallation is an area where we also plan to make several improvements. Our Kyma CLI graduated from Kyma Incubator and allows for a quick, simple, and platform-agnostic local installation of Kyma. Our local installation instructions are going to be updated to use this convenient tool. \n\nWe want to prepare better default configurations to limit the number of steps required to install Kyma. For example, we will remove `sed` commands from the installation manual. Our goal is to have a very streamlined installation process but at the same time keep the possibility to configure and adjust every tiny setting in Kyma components, which is made possible by our powerful Kyma operator - the Kyma Installer.\n\nAnother improvement for Kyma users working with Google Cloud Platform is a possibility to install Kyma directly from [GCP Marketplace](https://console.cloud.google.com/marketplace/details/sap-public/kyma) with just a few clicks. This cool feature is already available and allows you to install Kyma 1.1. Because of its limited configuration options, treat it more like a preview than a polished deployment option but also know that we're continuing our work on this topic.\n\nHere are some other things that will come in Kyma 1.2 Istanbul:\n- Defining limits and resource quotas when a Namespace is created through the UI.\n- Easily navigating to the external URL of your services exposed through API management.\n- Passing custom headers through eventing.\n- Configuration for replacing built-in NATS with external messaging middleware.\n\nYou can find all the items planned for the 1.2 release in our [Zenhub](https://app.zenhub.com/workspaces/kyma---all-repositories-5b6d5985084045741e744dea/reports/release?release=5cb59383709ee87123145468).\n\nKyma 1.2 Istanbul is scheduled for release on 13.06.2019. Keep an eye out for more Kyma news and updates on our blog. See you around! \n","excerpt":"Just as we initially promised, the developers are working hard to deliver new features and improvements every four weeks. Our last release is already available for 3 weeks, which means that the next Kyma version will be available in about a week. This time around, the release gets its codename from a city with an incredibly rich history, one that bridges the gap (literally!) between the East and the West. Kyma 1.2 Istanbul has a very rich history of improvements and new features and continues to aid the users in bridging the gap between different pieces of software. What's in store for the 1.2 release?","fields":{"slug":"/blog/2019/6/3/release-12-plan","assetsPath":"/assets/blog-posts/2019-06-03-release-1.2-plan/","date":"June 03, 2019","postInfo":{"fileName":"release-12-plan","year":2019,"month":6,"day":3}},"frontmatter":{"title":"Kyma 1.2 Istanbul scheduled for release on 13.06.2019","author":{"name":"Piotr Bochynski, Product Owner @Kyma"},"tags":["release"],"type":null,"releaseTag":null,"redirectFrom":["/blog/release-12-plan"]}},"next":{"id":"e806c68c-9017-5136-849d-798632de9dc2","rawMarkdownBody":"\nCloud-native application development is now a hot topic in the industry. Developers want to use modern languages, write microservices or even serverless functions. They expect high scalability with modern monitoring tools like Prometheus and Grafana. Kubernetes and CNCF landscape projects are no longer perceived as hype for early adopters. This is the mainstream now.\n\nIf you start a new, green field project you are lucky - you can dive into the great variety of tools and frameworks and use them. But how to pick the right tools? At the moment of writing this post, there are 686 projects registered in the [CNCF landscape](https://landscape.cncf.io/).\n\nWe also have the less lucky developers who still have to deal with applications designed when monoliths were cool. What about them? Can they benefit from cloud-native patterns? Yes, they can!\n<!-- overview -->\n\n# Imagine your legacy application\nYou probably have some applications you have to extend or integrate with but you are not happy with that fact. There can be a few reasons for it:\n- It requires writing code in the language you don't know and you want to use only Golang or JavaScript.\n- It is possible to add a new feature to the application but it requires a complex redeployment process which is risky.\n- You just don't want to touch it because it is fragile and adding anything can make it unstable.\n- You want to write an extension which can be scaled independently of the application.\n\n# WordPress as an example\nI prepared some example to help your imagination. The simple scenario with WordPress as a legacy application. Imagine you are running some commerce site and you created a blog on WordPress showing product reviews and tests. Now you want to engage your customers and you enabled comments in your blog posts. Users should see their comments immediately published, but you don't have time to moderate the content. The idea is to publish only positive comments automatically, and put other comments on hold.\n\nYou could use WordPress hook `comment_post` and implement a plugin in PHP. But it won't work for me. I don't know PHP, and my team mates don't either. I would like to use external systems (text analytics, slack, maybe more in the future), and I don't want to deal with secrets and authorization flows in WordPress side. Additionally, I want to utilize all modern DevOps practices and patterns, like [12 Factor App](https://12factor.net). In other words: me and my team want to do cool, cloud native stuff on top of Kubernetes, instead of be WordPress maintainers.\n\nOf course, in this simple scenario microservices, Kubernetes, Service Mesh, and other tools would be overkill but the real-world use cases are more complex, and you can imagine how this initial flow can grow in the future.\n\n# Implementation plan\n\nLet's implement and deploy our example. I will use:\n- A Kubernetes cluster from Google Kubernetes Engine (GKE) to deploy both WordPress and my code\n- Knative eventing and NATS as a messaging middleware to decouple WordPress from my extension\n- Istio Service Mesh together with Prometheus, Grafana, and Jaeger to have monitoring and tracing\n- Kubeless as a serverless engine for my code\n- Grafana and Loki to manage logs\n- Service Catalog, WordPress Connector for Kyma and Kyma Application Broker to bind WordPress API and Events to my code\n\n# Installation\nBased on the above list, you can expect a long installation process but I will use a Kyma operator that will do everything for me. All you need is a Google account and a Google Cloud Platform (GCP) project. If you don't have it yet, create one and Google will give a 12-month free trial with $300 credit to run your cluster.\n\n## Prepare the GKE cluster with Kyma\nFollow the [installation guide](https://kyma-project.io/docs/1.2/root/kyma/#installation-install-kyma-on-a-cluster) for GKE or just execute the following commands, replacing placeholders with proper values:\n\n```bash\n# Set ENV variables. See sample values in comments:\nexport KYMA_VERSION={KYMA_RELEASE_VERSION}      # 1.2.0\nexport CLUSTER_NAME={CLUSTER_NAME_YOU_WANT}     # kyma-cluster\nexport GCP_PROJECT={YOUR_GCP_PROJECT}           # myproject\nexport GCP_ZONE={GCP_ZONE_TO_DEPLOY_TO}         # europe-west1-b\n\n# Create a cluster\ngcloud container --project \"$GCP_PROJECT\" clusters \\\ncreate \"$CLUSTER_NAME\" --zone \"$GCP_ZONE\" \\\n--cluster-version \"1.12\" --machine-type \"n1-standard-4\" \\\n--addons HorizontalPodAutoscaling,HttpLoadBalancing\n\n# Add the current user as an admin\ngcloud container clusters get-credentials $CLUSTER_NAME --zone $GCP_ZONE --project $GCP_PROJECT\nkubectl create clusterrolebinding cluster-admin-binding --clusterrole=cluster-admin --user=$(gcloud config get-value account)\n\n# Install Tiller\nkubectl apply -f https://raw.githubusercontent.com/kyma-project/kyma/$KYMA_VERSION/installation/resources/tiller.yaml\n\n# Install Kyma\nkubectl apply -f https://github.com/kyma-project/kyma/releases/download/$KYMA_VERSION/kyma-installer-cluster.yaml\n\n# Show the Kyma installation progress. Stop the script with `Ctrl+C` when the installation finishes.\nwhile true; do \\\n  kubectl -n default get installation/kyma-installation -o jsonpath=\"{'Status: '}{.status.state}{', description: '}{.status.description}\"; echo; \\\n  sleep 5; \\\ndone\n```\n\n## Access Kyma\n\n> **NOTE:** Follow steps in this section only if you installed Kyma from the instructions in this blog post. If you followed the official Kyma documentation, skip this section as the installation steps cover adding a self-signed certificate and accessing the cluster.\n\nThe simple installation guide we followed uses a self-signed certificate and an `xip.io` domain. Such a certificate will be rejected by your browser so you have to set it as trusted. \n```bash\n# When the installation finishes, add a Kyma self-signed certificate to the trusted certificates (MacOS):\ntmpfile=$(mktemp /tmp/temp-cert.XXXXXX) \\\n&& kubectl get configmap net-global-overrides -n kyma-installer -o jsonpath='{.data.global\\.ingress\\.tlsCrt}' | base64 --decode > $tmpfile \\\n&& sudo security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain $tmpfile \\\n&& rm $tmpfile\n```\n\nRun these commands to display the Console URL, login, and password:\n```bash\necho 'Kyma Console Url:'\necho `kubectl get virtualservice core-console -n kyma-system -o jsonpath='{ .spec.hosts[0] }'`\n\necho 'User admin@kyma.cx, password:'\necho `kubectl get secret admin-user -n kyma-system -o jsonpath=\"{.data.password}\" | base64 --decode`\n```\nYou should get a similar result:\n```console\nKyma Console Url:\nconsole.1.2.3.4.xip.io\nUser admin@kyma.cx, password:\nEca23NyShqwK\n```\nYou can now open the Kyma Console URL in the browser and log in with the provided credentials. \n\n![Kyma Console](./console.png)\n\n## WordPress installation\nIf you already have WordPress installed, you can go to the next step. If not, you can easily deploy WordPress with a few commands:\n```bash\n# Create a Namespace\nkubectl create namespace wordpress\n\n# Deploy WordPress\nkubectl -n wordpress apply -f https://raw.githubusercontent.com/kyma-project/website/master/content/blog-posts/2019-07-08-extend-wordpress/wordpress-deployment.yaml\n```\n\nWait a few seconds for WordPress to start. You can check the status in the **Deployments** section.\n\nWhen the status of all deployments is `RUNNING`, navigate to [https://wordpress.1.2.3.4.xip.io]() replacing the `1.2.3.4` IP with the one for your cluster. Then complete the installation wizard. \n\n## Kyma plugin for WordPress\n\nBefore you install plugins, ensure that you have the proper configuration of Permalinks. Log into WordPress as an admin, go to **Settings** -> **Permalinks**, select the `Post name` option and save your changes.\nDownload the following plugins:\n- [Basic Auth](https://github.com/WP-API/Basic-Auth/archive/master.zip) - for more details go to this [GitHub repository](https://github.com/WP-API/Basic-Auth)\n- [Kyma Connector](https://github.com/kyma-incubator/wordpress-connector/archive/master.zip) - for more details go to this [GitHub repository](https://github.com/kyma-incubator/wordpress-connector)\nIn the left navigation, go to **Plugins** -> **Add New** -> **Upload Plugin**. Choose the Basic Auth and Kyma Connector plugins from your disk to install and activate them.\nGo to **Settings** -> **Kyma Connector**, uncheck the **Verify SSL** option (you need it because the default Kyma installation uses self-signed certificates), provide the username and password you created during the installation, and save your changes. \n\n![Kyma Connector](./kyma-connector.png)\n\n# Connect WordPress to Kyma\n\nIn this step you establish a trusted connection between the WordPress instance and your Kyma cluster, both hosted on the same Kubernetes cluster. You also register WordPress API and WordPress Events in the Service Catalog and enable both in a selected Namespace.\n\nIn the Kyma Console navigate back to the home page, go to **Applications**, and create a new Application called `wordpress`.\n\nOpen it and press **Connect Application**. Copy the connection token URL to the clipboard. Go to the Kyma Connector Settings in WordPress, paste the token URL in the **Kyma Connection** field, and press **Connect**. You should see the success message in WordPress and a new entry inside the **Provided Services & Events** section of the `wordpress` Application in Kyma.\n\n![Application](./application.png)\n\n## Diasable SSL for Kyma->WordPress\n\nWordPress installed in a cluster uses a self-signed SSL certificate. Kyma default settings don't allow for such a connection. You need to explicitly turn it on:\n\n  1. Edit the `wordpress-application-gateway` Deployment in the `kyma-integration` Namespace. Run:\n      ```\n      kubectl -n kyma-integration edit deployment wordpress-application-gateway\n      ```\n  2. Edit the Deployment in Vim. Select `i` to start editing.\n  3. Find the **skipVerify** parameter and change its value to `true`.\n  4. Press **ESC**, type `:wq`, and click **ENTER** to write and quit.\n\nOne command to do it:\n```bash\n# Update kyma installer image to 1.1.0\nkubectl -n kyma-integration \\\n  patch deployment wordpress-application-gateway --type=json \\\n  -p='[{\"op\": \"replace\", \"path\": \"/spec/template/spec/containers/0/args/6\", \"value\": \"--skipVerify=true\"}]'\n```\n>**CAUTION:** The command assumes that **skipVerify** is the argument with the index 6 (0-based).\n\n# Enable WordPress Events and APIs in the default Namespace\n\nThe Kyma Application connectivity can expose APIs and Events (Async API) of Applications in the Service Catalog. To show WordPress in the Service Catalog, first, you need to bind the Application to a selected Namespace. Go to **Applications**, select the `wordpress` Application, press **Create Binding** and select the `default` Namespace. Now go to the `default` Namespace and open the Catalog - you should see WordPress API in the **Services** tab. Open it and have a look at API console and Events specification. We will react on `comment.post.v1` event and interact with `/wp/v2/comments/{id}` API. To make them available in the `default` Namespace click the **Add once** button and create an instance of the WordPress Service Class. Behind the scenes, the Application Connector creates the Application Gateway (a kind of proxy) that forwards requests from bounded services or functions to the WordPress instance. \n\n![Add WordPress Instance](./add-wordpress-instance.png)\n\n# Write your code\nYou did the wiring, so let's write some code. In the `default` Namespace create a new lambda named `review` and paste the following code in the **Settings & Code** editor:\n``` javascript\nconst Sentiment = require('sentiment');\nconst sentiment = new Sentiment();\nconst axios = require(\"axios\");\n\nmodule.exports = {\n    main: async function (event, context) {\n        let status = \"hold\";\n        console.log(\"Event data: %s\",JSON.stringify(event.data));\n        let comment = await getComment(event.data.commentId);\n        console.log(\"Comment: %s\",comment.content.raw);\n        let result = sentiment.analyze(comment.content.raw);\n        console.log(\"Sentiment: %s\",JSON.stringify(result));\n        let score = result.comparative;\n        if (score>0.2) {\n            status = \"approved\"\n        } \n        updateComment(comment.id, status, comment.content.raw, score);\n    }\n};\n\nasync function getComment(id) {\n    let commentUrl = `${process.env.WP_GATEWAY_URL}/wp/v2/comments/${id}?context=edit`\n    let response = await axios.get(commentUrl);\n    return response.data;\n}\n\nasync function updateComment(id, status, comment, score) {\n    let commentUrl = `${process.env.WP_GATEWAY_URL}/wp/v2/comments/${id}`;\n    const update = await axios.post(commentUrl,{status:status, content:comment+\"\\n--\\nscore:\"+score});\n    return update;\n}\n```\n\nIn the **Dependencies** section, add:\n```json\n{\n  \"dependencies\": {\n    \"axios\": \"^0.19.0\",\n    \"sentiment\": \"^5.0.1\"\n  }\n}\n```\nPress **Select Function Trigger**, choose your function which is the `comment.post` Event, and save the function. The trigger is available because you have the WordPress service instance in the `default` Namespace. \n\n# Binding\n\nGo to **Instances** under the **Service Management**, open the WordPress instance in the **Services** tab. Click **Bind Application**, select `review` function, set the **Prefix namespace value** to `WP_`, and confirm.\n\n![Binding](./binding.png)\n\nYou can now open the `review` lambda again and check if there is a new entry in **Service Bindings** section with `WP_GATEWAY_URL` environment variable.\n\n\n# Test it\n\nGo to WordPress main site and open the **Hello World!** blog post. Add the following 2 comments under the blog post:\n- I love it!\n- I hate it!\nGo to the WordPress **Dashboard** and check the comments. You should see that both comments have a score footer with the following sentiment values:\n- `1` for a positive comment\n- `-1` for a negative comment\nThe negative comment is waiting for moderation.\n\n![Comments](./comments.png)\n\n# Explore the benefits\n\nYour code runs using Istio Service Mesh with network secured by mutual TLS. You can see the metrics of your functions, such as latency, responses, errors and memory usage, with one click on Grafana Dashboard. You can trace your requests using Jaeger. And you can scale your functions independently from WordPress.\n\n# Summary\nWhy should you try Kyma? If you start a new project on Kubernetes, you will get carefully selected and best tools from the Cloud Native Landscape, which are already configured and integrated. If you want to move only a part of your project to the cloud and you have to keep legacy applications around, Kyma will help you to build extensions for them using modern tools on top of Kubernetes.\nAlso when you start a new project with a goal that the final solution should be extendable and customizable, considering Kyma to address these challenges from day one would offer benefits. \nPlease remember that Kyma is an open-source project which is actively developed (~80 contributors and ~600 GitHub stars) with the support from such a big company as SAP. \n\n# Next steps\n\nIn the next blog post, I will show you how to use services from cloud providers using the Open Service Broker API. \n","excerpt":"Cloud-native application development is now a hot topic in the industry. Developers want to use modern languages, write microservices or even serverless functions. They expect high scalability with modern monitoring tools like Prometheus and Grafana. Kubernetes and CNCF landscape projects are no longer perceived as hype for early adopters. This is the mainstream now. If you start a new, green field project you are lucky - you can dive into the great variety of tools and frameworks and use them. But how to pick the right tools? At the moment of writing this post, there are 686 projects registered in the CNCF landscape. We also have the less lucky developers who still have to deal with applications designed when monoliths were cool. What about them? Can they benefit from cloud-native patterns? Yes, they can!","fields":{"slug":"/blog/2019/7/8/extend-wordpress","assetsPath":"/assets/blog-posts/2019-07-08-extend-wordpress/","date":"July 08, 2019","postInfo":{"fileName":"extend-wordpress","year":2019,"month":7,"day":8}},"frontmatter":{"title":"Build a cloud-native extension for WordPress","author":{"name":"Piotr Bochynski, Product Owner @Kyma"},"tags":["technology","tutorial"],"type":null,"releaseTag":null,"redirectFrom":["/blog/2019-07-08-extend-wordpress"]}},"slidesBanner":{"bannerDuration":5000,"slides":[{"text":"Don't miss the session by Piotr Kopczynski at Helm Summit on September 11 at 15:47.","url":"https://helmsummit2019.sched.com/event/S8sS","startDate":"09/09/2019","endDate":"12/09/2019"}]},"locale":"en"}}}