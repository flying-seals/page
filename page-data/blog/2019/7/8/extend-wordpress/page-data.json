{"componentChunkName":"component---src-views-blog-single-index-tsx","path":"/blog/2019/7/8/extend-wordpress","webpackCompilationHash":"aefb7e842b40c338951f","result":{"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/blog/2019/7/8/extend-wordpress","post":{"id":"e806c68c-9017-5136-849d-798632de9dc2","rawMarkdownBody":"\nCloud-native application development is now a hot topic in the industry. Developers want to use modern languages, write microservices or even serverless functions. They expect high scalability with modern monitoring tools like Prometheus and Grafana. Kubernetes and CNCF landscape projects are no longer perceived as hype for early adopters. This is the mainstream now.\n\nIf you start a new, green field project you are lucky - you can dive into the great variety of tools and frameworks and use them. But how to pick the right tools? At the moment of writing this post, there are 686 projects registered in the [CNCF landscape](https://landscape.cncf.io/).\n\nWe also have the less lucky developers who still have to deal with applications designed when monoliths were cool. What about them? Can they benefit from cloud-native patterns? Yes, they can!\n<!-- overview -->\n\n# Imagine your legacy application\nYou probably have some applications you have to extend or integrate with but you are not happy with that fact. There can be a few reasons for it:\n- It requires writing code in the language you don't know and you want to use only Golang or JavaScript.\n- It is possible to add a new feature to the application but it requires a complex redeployment process which is risky.\n- You just don't want to touch it because it is fragile and adding anything can make it unstable.\n- You want to write an extension which can be scaled independently of the application.\n\n# WordPress as an example\nI prepared some example to help your imagination. The simple scenario with WordPress as a legacy application. Imagine you are running some commerce site and you created a blog on WordPress showing product reviews and tests. Now you want to engage your customers and you enabled comments in your blog posts. Users should see their comments immediately published, but you don't have time to moderate the content. The idea is to publish only positive comments automatically, and put other comments on hold.\n\nYou could use WordPress hook `comment_post` and implement a plugin in PHP. But it won't work for me. I don't know PHP, and my team mates don't either. I would like to use external systems (text analytics, slack, maybe more in the future), and I don't want to deal with secrets and authorization flows in WordPress side. Additionally, I want to utilize all modern DevOps practices and patterns, like [12 Factor App](https://12factor.net). In other words: me and my team want to do cool, cloud native stuff on top of Kubernetes, instead of be WordPress maintainers.\n\nOf course, in this simple scenario microservices, Kubernetes, Service Mesh, and other tools would be overkill but the real-world use cases are more complex, and you can imagine how this initial flow can grow in the future.\n\n# Implementation plan\n\nLet's implement and deploy our example. I will use:\n- A Kubernetes cluster from Google Kubernetes Engine (GKE) to deploy both WordPress and my code\n- Knative eventing and NATS as a messaging middleware to decouple WordPress from my extension\n- Istio Service Mesh together with Prometheus, Grafana, and Jaeger to have monitoring and tracing\n- Kubeless as a serverless engine for my code\n- Grafana and Loki to manage logs\n- Service Catalog, WordPress Connector for Kyma and Kyma Application Broker to bind WordPress API and Events to my code\n\n# Installation\nBased on the above list, you can expect a long installation process but I will use a Kyma operator that will do everything for me. All you need is a Google account and a Google Cloud Platform (GCP) project. If you don't have it yet, create one and Google will give a 12-month free trial with $300 credit to run your cluster.\n\n## Prepare the GKE cluster with Kyma\nFollow the [installation guide](https://kyma-project.io/docs/1.2/root/kyma/#installation-install-kyma-on-a-cluster) for GKE or just execute the following commands, replacing placeholders with proper values:\n\n```bash\n# Set ENV variables. See sample values in comments:\nexport KYMA_VERSION={KYMA_RELEASE_VERSION}      # 1.2.0\nexport CLUSTER_NAME={CLUSTER_NAME_YOU_WANT}     # kyma-cluster\nexport GCP_PROJECT={YOUR_GCP_PROJECT}           # myproject\nexport GCP_ZONE={GCP_ZONE_TO_DEPLOY_TO}         # europe-west1-b\n\n# Create a cluster\ngcloud container --project \"$GCP_PROJECT\" clusters \\\ncreate \"$CLUSTER_NAME\" --zone \"$GCP_ZONE\" \\\n--cluster-version \"1.12\" --machine-type \"n1-standard-4\" \\\n--addons HorizontalPodAutoscaling,HttpLoadBalancing\n\n# Add the current user as an admin\ngcloud container clusters get-credentials $CLUSTER_NAME --zone $GCP_ZONE --project $GCP_PROJECT\nkubectl create clusterrolebinding cluster-admin-binding --clusterrole=cluster-admin --user=$(gcloud config get-value account)\n\n# Install Tiller\nkubectl apply -f https://raw.githubusercontent.com/kyma-project/kyma/$KYMA_VERSION/installation/resources/tiller.yaml\n\n# Install Kyma\nkubectl apply -f https://github.com/kyma-project/kyma/releases/download/$KYMA_VERSION/kyma-installer-cluster.yaml\n\n# Show the Kyma installation progress. Stop the script with `Ctrl+C` when the installation finishes.\nwhile true; do \\\n  kubectl -n default get installation/kyma-installation -o jsonpath=\"{'Status: '}{.status.state}{', description: '}{.status.description}\"; echo; \\\n  sleep 5; \\\ndone\n```\n\n## Access Kyma\n\n> **NOTE:** Follow steps in this section only if you installed Kyma from the instructions in this blog post. If you followed the official Kyma documentation, skip this section as the installation steps cover adding a self-signed certificate and accessing the cluster.\n\nThe simple installation guide we followed uses a self-signed certificate and an `xip.io` domain. Such a certificate will be rejected by your browser so you have to set it as trusted. \n```bash\n# When the installation finishes, add a Kyma self-signed certificate to the trusted certificates (MacOS):\ntmpfile=$(mktemp /tmp/temp-cert.XXXXXX) \\\n&& kubectl get configmap net-global-overrides -n kyma-installer -o jsonpath='{.data.global\\.ingress\\.tlsCrt}' | base64 --decode > $tmpfile \\\n&& sudo security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain $tmpfile \\\n&& rm $tmpfile\n```\n\nRun these commands to display the Console URL, login, and password:\n```bash\necho 'Kyma Console Url:'\necho `kubectl get virtualservice core-console -n kyma-system -o jsonpath='{ .spec.hosts[0] }'`\n\necho 'User admin@kyma.cx, password:'\necho `kubectl get secret admin-user -n kyma-system -o jsonpath=\"{.data.password}\" | base64 --decode`\n```\nYou should get a similar result:\n```console\nKyma Console Url:\nconsole.1.2.3.4.xip.io\nUser admin@kyma.cx, password:\nEca23NyShqwK\n```\nYou can now open the Kyma Console URL in the browser and log in with the provided credentials. \n\n![Kyma Console](./console.png)\n\n## WordPress installation\nIf you already have WordPress installed, you can go to the next step. If not, you can easily deploy WordPress with a few commands:\n```bash\n# Create a Namespace\nkubectl create namespace wordpress\n\n# Deploy WordPress\nkubectl -n wordpress apply -f https://raw.githubusercontent.com/kyma-project/website/master/content/blog-posts/2019-07-08-extend-wordpress/wordpress-deployment.yaml\n```\n\nWait a few seconds for WordPress to start. You can check the status in the **Deployments** section.\n\nWhen the status of all deployments is `RUNNING`, navigate to [https://wordpress.1.2.3.4.xip.io]() replacing the `1.2.3.4` IP with the one for your cluster. Then complete the installation wizard. \n\n## Kyma plugin for WordPress\n\nBefore you install plugins, ensure that you have the proper configuration of Permalinks. Log into WordPress as an admin, go to **Settings** -> **Permalinks**, select the `Post name` option and save your changes.\nDownload the following plugins:\n- [Basic Auth](https://github.com/WP-API/Basic-Auth/archive/master.zip) - for more details go to this [GitHub repository](https://github.com/WP-API/Basic-Auth)\n- [Kyma Connector](https://github.com/kyma-incubator/wordpress-connector/archive/master.zip) - for more details go to this [GitHub repository](https://github.com/kyma-incubator/wordpress-connector)\nIn the left navigation, go to **Plugins** -> **Add New** -> **Upload Plugin**. Choose the Basic Auth and Kyma Connector plugins from your disk to install and activate them.\nGo to **Settings** -> **Kyma Connector**, uncheck the **Verify SSL** option (you need it because the default Kyma installation uses self-signed certificates), provide the username and password you created during the installation, and save your changes. \n\n![Kyma Connector](./kyma-connector.png)\n\n# Connect WordPress to Kyma\n\nIn this step you establish a trusted connection between the WordPress instance and your Kyma cluster, both hosted on the same Kubernetes cluster. You also register WordPress API and WordPress Events in the Service Catalog and enable both in a selected Namespace.\n\nIn the Kyma Console navigate back to the home page, go to **Applications**, and create a new Application called `wordpress`.\n\nOpen it and press **Connect Application**. Copy the connection token URL to the clipboard. Go to the Kyma Connector Settings in WordPress, paste the token URL in the **Kyma Connection** field, and press **Connect**. You should see the success message in WordPress and a new entry inside the **Provided Services & Events** section of the `wordpress` Application in Kyma.\n\n![Application](./application.png)\n\n## Diasable SSL for Kyma->WordPress\n\nWordPress installed in a cluster uses a self-signed SSL certificate. Kyma default settings don't allow for such a connection. You need to explicitly turn it on:\n\n  1. Edit the `wordpress-application-gateway` Deployment in the `kyma-integration` Namespace. Run:\n      ```\n      kubectl -n kyma-integration edit deployment wordpress-application-gateway\n      ```\n  2. Edit the Deployment in Vim. Select `i` to start editing.\n  3. Find the **skipVerify** parameter and change its value to `true`.\n  4. Press **ESC**, type `:wq`, and click **ENTER** to write and quit.\n\nOne command to do it:\n```bash\n# Update kyma installer image to 1.1.0\nkubectl -n kyma-integration \\\n  patch deployment wordpress-application-gateway --type=json \\\n  -p='[{\"op\": \"replace\", \"path\": \"/spec/template/spec/containers/0/args/6\", \"value\": \"--skipVerify=true\"}]'\n```\n>**CAUTION:** The command assumes that **skipVerify** is the argument with the index 6 (0-based).\n\n# Enable WordPress Events and APIs in the default Namespace\n\nThe Kyma Application connectivity can expose APIs and Events (Async API) of Applications in the Service Catalog. To show WordPress in the Service Catalog, first, you need to bind the Application to a selected Namespace. Go to **Applications**, select the `wordpress` Application, press **Create Binding** and select the `default` Namespace. Now go to the `default` Namespace and open the Catalog - you should see WordPress API in the **Services** tab. Open it and have a look at API console and Events specification. We will react on `comment.post.v1` event and interact with `/wp/v2/comments/{id}` API. To make them available in the `default` Namespace click the **Add once** button and create an instance of the WordPress Service Class. Behind the scenes, the Application Connector creates the Application Gateway (a kind of proxy) that forwards requests from bounded services or functions to the WordPress instance. \n\n![Add WordPress Instance](./add-wordpress-instance.png)\n\n# Write your code\nYou did the wiring, so let's write some code. In the `default` Namespace create a new lambda named `review` and paste the following code in the **Settings & Code** editor:\n``` javascript\nconst Sentiment = require('sentiment');\nconst sentiment = new Sentiment();\nconst axios = require(\"axios\");\n\nmodule.exports = {\n    main: async function (event, context) {\n        let status = \"hold\";\n        console.log(\"Event data: %s\",JSON.stringify(event.data));\n        let comment = await getComment(event.data.commentId);\n        console.log(\"Comment: %s\",comment.content.raw);\n        let result = sentiment.analyze(comment.content.raw);\n        console.log(\"Sentiment: %s\",JSON.stringify(result));\n        let score = result.comparative;\n        if (score>0.2) {\n            status = \"approved\"\n        } \n        updateComment(comment.id, status, comment.content.raw, score);\n    }\n};\n\nasync function getComment(id) {\n    let commentUrl = `${process.env.WP_GATEWAY_URL}/wp/v2/comments/${id}?context=edit`\n    let response = await axios.get(commentUrl);\n    return response.data;\n}\n\nasync function updateComment(id, status, comment, score) {\n    let commentUrl = `${process.env.WP_GATEWAY_URL}/wp/v2/comments/${id}`;\n    const update = await axios.post(commentUrl,{status:status, content:comment+\"\\n--\\nscore:\"+score});\n    return update;\n}\n```\n\nIn the **Dependencies** section, add:\n```json\n{\n  \"dependencies\": {\n    \"axios\": \"^0.19.0\",\n    \"sentiment\": \"^5.0.1\"\n  }\n}\n```\nPress **Select Function Trigger**, choose your function which is the `comment.post` Event, and save the function. The trigger is available because you have the WordPress service instance in the `default` Namespace. \n\n# Binding\n\nGo to **Instances** under the **Service Management**, open the WordPress instance in the **Services** tab. Click **Bind Application**, select `review` function, set the **Prefix namespace value** to `WP_`, and confirm.\n\n![Binding](./binding.png)\n\nYou can now open the `review` lambda again and check if there is a new entry in **Service Bindings** section with `WP_GATEWAY_URL` environment variable.\n\n\n# Test it\n\nGo to WordPress main site and open the **Hello World!** blog post. Add the following 2 comments under the blog post:\n- I love it!\n- I hate it!\nGo to the WordPress **Dashboard** and check the comments. You should see that both comments have a score footer with the following sentiment values:\n- `1` for a positive comment\n- `-1` for a negative comment\nThe negative comment is waiting for moderation.\n\n![Comments](./comments.png)\n\n# Explore the benefits\n\nYour code runs using Istio Service Mesh with network secured by mutual TLS. You can see the metrics of your functions, such as latency, responses, errors and memory usage, with one click on Grafana Dashboard. You can trace your requests using Jaeger. And you can scale your functions independently from WordPress.\n\n# Summary\nWhy should you try Kyma? If you start a new project on Kubernetes, you will get carefully selected and best tools from the Cloud Native Landscape, which are already configured and integrated. If you want to move only a part of your project to the cloud and you have to keep legacy applications around, Kyma will help you to build extensions for them using modern tools on top of Kubernetes.\nAlso when you start a new project with a goal that the final solution should be extendable and customizable, considering Kyma to address these challenges from day one would offer benefits. \nPlease remember that Kyma is an open-source project which is actively developed (~80 contributors and ~600 GitHub stars) with the support from such a big company as SAP. \n\n# Next steps\n\nIn the next blog post, I will show you how to use services from cloud providers using the Open Service Broker API. \n","excerpt":"Cloud-native application development is now a hot topic in the industry. Developers want to use modern languages, write microservices or even serverless functions. They expect high scalability with modern monitoring tools like Prometheus and Grafana. Kubernetes and CNCF landscape projects are no longer perceived as hype for early adopters. This is the mainstream now. If you start a new, green field project you are lucky - you can dive into the great variety of tools and frameworks and use them. But how to pick the right tools? At the moment of writing this post, there are 686 projects registered in the CNCF landscape. We also have the less lucky developers who still have to deal with applications designed when monoliths were cool. What about them? Can they benefit from cloud-native patterns? Yes, they can!","fields":{"slug":"/blog/2019/7/8/extend-wordpress","assetsPath":"/assets/blog-posts/2019-07-08-extend-wordpress/","date":"July 08, 2019","postInfo":{"fileName":"extend-wordpress","year":2019,"month":7,"day":8}},"frontmatter":{"title":"Build a cloud-native extension for WordPress","author":{"name":"Piotr Bochynski, Product Owner @Kyma"},"tags":["technology","tutorial"],"type":null,"releaseTag":null,"redirectFrom":["/blog/2019-07-08-extend-wordpress"]}},"assetsPath":"/assets/blog-posts/2019-07-08-extend-wordpress/","previous":{"id":"8563db8c-49cd-5fa4-ab83-eafbcc5b04e8","rawMarkdownBody":"\nIt's about time to sail our ship to Istanbul and see all of the new features and tweaks that come with the 1.2 release. This time around we focused on streamlining the installation flow, providing a simpler way of testing lambda functions, giving more power and flexibility to Kyma Eventing, migrating to a new version of Istio, and providing even more useful documentation.\n\n<!-- overview -->\n\nThe highlights of Kyma 1.2 Istanbul include:\n\n- [Streamlined installation](#installation) - We enabled platform-agnostic local installation with the Kyma CLI, enabled Kyma installation through GCP Marketplace, and simplified all cluster installation flows.\n- [Testing lambda functions in the UI](#testing-lambda-functions-in-the-ui) - We added an option to test lambda functions through the Console UI.\n- [Migration to Istio 1.1.6](#service-mesh) - We migrated to a new, more secure and stable version of Istio.\n- [Migration to Istio in the Application Connector](#migration-to-istio) - We moved from NGINX Ingress to Istio in the Application Connector.\n- [Configuration for using different messaging middleware](#choose-and-configure-a-custom-messaging-middleware) - We added configuration that allows using different messaging middleware in Kyma Eventing.\n\nSee the overview of all changes in this release:\n\n- [Application Connector](#application-connector) - Migration to Istio, support for custom headers and query parameters in authentication requests\n- [Console](#console) - Testing lambda functions through the UI, more configuration options available at the moment of Namespace creation\n- [Installation](#installation) - Local installation with Kyma CLI, Kyma available trough GCP Marketplace, streamlined cluster installation flows\n- [Documentation](#documentation) - New configuration, troubleshooting, and Headless CMS metadata documents, tutorial for customizing the Documentation view in the Console UI, testing bundle with sample documentation\n- [Eventing](#eventing) - Choosing and configuring a custom messaging middleware, sending custom metadata with published Events, an example for triggering microservices with Events\n- [Observability](#observability) - Early version of Kiali added to Istio\n- [Service Mesh](#service-mesh) - Istio update to version 1.1.6\n\nRead about a known issue for [Observability](#known-issues).\n\n> **CAUTION:** Before you upgrade to Kyma 1.2, read the [Migration Guide](https://github.com/kyma-project/kyma/blob/release-1.2/docs/migration-guides/1.1-1.2.md) which describes necessary manual actions required by the Event Bus, the Asset Store, and the Application Connector.\n\n---\n\n## Application Connector\n\n### Migration to Istio\n\nFrom the very beginning of the Kyma project, the Application Connector has been exposed using the NGINX Ingress. After the recent changes in Istio 1.x which included support for client certificates, we decided to migrate to Istio as did the rest of Kyma components. We are proud to announce that the migration is complete and we are already benefiting from a number of advantages including easier maintenance and a smaller number of components in the implementation.\n\nRead [this](/docs/1.2/components/application-connector/#architecture-architecture) document to learn more about the role Istio plays in the Application Connector.\n\n### Custom headers and query parameters in authentication requests\n\nTo facilitate the integration of APIs that require sending additional headers and query parameters with every request to an external system, we allow the developers to provide a custom list of the headers and query parameters when registering an API in the Application Registry. The Proxy service reads this configuration and enriches each call from an API to an external service with the required items.\n\nRead [this](/docs/1.2/components/application-connector/#tutorials-register-a-secured-api-specify-custom-headers-and-query-parameters-for-authentication-requests) document to learn more.\n\n## Console\n\n### Testing lambda functions in the UI\n\nNow you can test your lambda functions directly in the Console UI. Use any of the Event samples available in your Namespace or any custom payload to dry–run a function before connecting it to your live system's business events.\n\n### More configuration options at the moment of Namespace creation\n\nUsers can now configure more of the important Namespace options when they create it using the UI. The available options include setting memory consumption limits and choosing whether Istio should handle all of the communication between Pods in the Namespace.\n\n## Installation\n\n### Kyma available on GCP Marketplace\n\nDeploying on GKE is now easier than ever as you can get a fully functional Kyma deployment with `http://xip.io/` straight from the GCP Marketplace. Follow [this link](https://console.cloud.google.com/marketplace/details/sap-public/kyma) to find Kyma on the Marketplace, read [this](/docs/1.2/root/kyma/#installation-install-kyma-on-a-cluster) document to get detailed installation instructions, and watch [this video](https://www.youtube.com/watch?v=hxVhQqI1B5A) for a detailed walkthrough. Enjoy!\n\n### Platform-agnostic local deployments with Kyma CLI\n\nOur very own [Kyma CLI](https://github.com/kyma-project/cli) graduated from the Incubator and became an integral part of Kyma with the 1.2 release. From now on you can use simple `kyma` commands to easily deploy Kyma on your local machine, no matter what OS you're running - all you have to do is install our proprietary CLI tool. The local installation flow is now updated to use the CLI and we are retiring the old installation approach that used custom scripts.\n\nTo experience the convenience the Kyma CLI brings to the table, follow [our documentation](/docs/1.2/root/kyma/#installation-install-kyma-locally) to install Kyma on your machine.\n\n### Simpler cluster installation\n\nThe existing cluster installation flows were significantly simplified. The `sed` commands and the cluster configuration template file are now gone in favor of a set of `kubectl` calls. Now you simply set up your cluster, apply the desired configuration with `kubectl`, and wait for the magic to happen. For more details, see the [installation documentation](/docs/1.2/root/kyma/#installation-installation).\n\n## Documentation\n\n### Configuration documents for components\n\nAfter preparing a set of generic configuration documents in the last release, this time around we focused on specific Kyma components. The idea was to create configuration documents that list all configurable parameters from the `values.yaml` file of each of the components' charts and sub-charts that you can configure with overrides. Not all components have their **Configuration** documents ready, but you can expect full coverage in the near future.\n\n### Troubleshooting guides\n\nAs we interact with the community, we take note of recurring issues and misunderstandings that affect different components. We decide to gather these cases under the **Troubleshooting** documentation type to help the users deal with the most common issues easily. The troubleshooting documents are now available for the [Service Mesh](/docs/1.2/components/service-mesh/#troubleshooting-troubleshooting) and the general [Kyma](/docs/1.2/root/kyma/#troubleshooting-troubleshooting-overview) topic.\n\n### Markdown documents in Headless CMS\n\nIf you've ever had any doubts regarding what the structure of a Markdown document processed by Headless CMS should look like, we come with a solution. See the [document](/docs/1.2/components/headless-cms/#details-markdown-documents) describing the required metadata and content of a Markdown file.\n\n### How to modify the Documentation view in the Console UI\n\nWe prepared a tutorial that shows how to adjust the Documentation view in the Console UI. Based on it, you create a new Prometheus documentation section that contains Concepts and Guides topics and a set of Markdown subdocuments. [Try it](/docs/1.2/components/headless-cms/#tutorial-add-new-documents-to-the-documentation-view-in-the-console-ui) on your own.\n\n### Testing bundle with sample documentation\n\nThe testing bundle is now enriched with [sample documentation](https://github.com/kyma-project/addons/tree/master/addons/testing-0.0.1/docs). There are examples of Markdown documents together with OpenAPI and AsyncAPI specifications. See the testing bundle for details on how different document types render in the Console UI.  \n\n\n## Eventing\n\n### Choose and configure a custom messaging middleware\n\nOut of the box, Kyma comes with NATS Streaming as the default messaging middleware. With this release, we're giving you the tools to choose your own messaging middleware that best fits your needs from the usage, volume, and costs perspective. The only requirement is that the middleware must have Knative eventing-based [ClusterChannelProvisioner](https://knative.dev/docs/eventing/channels/) available. Compatible solutions include Google PubSub, Kafka, and NATSS.\n\n### Sending custom metadata with published Events\n\nThe applications sending Events to Kyma can now send additional context or metadata by sending headers with the `ce-` prefix, for example, `ce-correlation-id`. These headers are delivered to the lambda function.\n\n### Example for triggering microservices with Events\n\nWe prepared a self-contained example that shows how to configure an Event trigger for a microservice deployed in Kyma. This is extremely useful for applications written in Java which want to use Events as a trigger.\n\n\n## Observability\n\n### Early integration of Kiali\n\nEarly integration of Kiali is available as part of Istio. To enable Kiali, ensure that the monitoring module is installed and set the **kiali.enabled** parameter to `true`. The Kiali UI will be accessible under the `kiali` subdomain. The early integration is based on static user security. To learn how to get the Kiali UI password, see [this](https://github.com/kyma-project/kyma/tree/master/resources/istio) document.\n\n### Known issues\n\nKiali is not accessible after installation when enabled as part of the Installer configuration. It should be accessible on Minikube at `https://kiali.kyma.local`.\nTo access it this way, use the workaround for now and add the `kiali` prefix to the **hosts** attribute in the `kiali-virtualservice` resource:\n```\nkubectl -n istio-system edit virtualservices kiali-virtualservice\n```\n```\nhosts:\n- kiali.kyma.local\n```\n\n## Service Mesh\n\n### Istio updated to 1.1.6\n\nThe new release comes with Istio updated to 1.1.6. Previously Kyma used version 1.1.0, but due to a security issue and problems with the Ingress Gateway, we moved to a newer version. The update makes the Service Mesh more secure and stable - the Ingress Gateway issues seen in the previous version that caused port configurations not being applied properly are now resolved.\n","excerpt":"It's about time to sail our ship to Istanbul and see all of the new features and tweaks that come with the 1.2 release. This time around we focused on streamlining the installation flow, providing a simpler way of testing lambda functions, giving more power and flexibility to Kyma Eventing, migrating to a new version of Istio, and providing even more useful documentation.","fields":{"slug":"/blog/2019/6/13/release-notes-12","assetsPath":"/assets/blog-posts/2019-06-13-release-notes-1.2/","date":"June 13, 2019","postInfo":{"fileName":"release-notes-12","year":2019,"month":6,"day":13}},"frontmatter":{"title":"Kyma 1.2 Istanbul","author":{"name":"Tomasz Papiernik, Technical Writer @Kyma"},"tags":["release-notes"],"type":"release","releaseTag":"1.2.0","redirectFrom":["/blog/release-notes-12"]}},"next":{"id":"1267ca79-5465-505c-b637-f87c3af76194","rawMarkdownBody":"\nAfter a short stop in Istanbul, we move forward to Jakarta with the brand new Kyma 1.3 release, which brings you a set of significant improvements in many components, including the Console and Kyma CLI. It also introduces the CloudEvents specification 0.3 for Event delivery and comes with even more useful documents that will guide you through the project. Read on to find out what Kyma 1.3 has to offer.\n\n<!-- overview -->\n\nSee the overview of all changes in this release:\n\n- [Application Connector](#application-connector) - Fetching API specification secured with Basic Auth or OAuth, automatic generation of the root Certificate Authority, additional headers and query parameters stored in a secured way\n- [Console](#console) - Less information noise in lambda logs, easy Namespace labeling and filtering, API list streamed using WebSockets, hide irrelevant navigation nodes, DevX improvements for the **Lambda** view, Console Backend observability improved\n- [Core and Supporting](#core-and-supporting) - Documentation component\n- [Service Management](#service-management) - Service Catalog migration from \"API Server\" to \"CRD only\"\n- [Kyma CLI](#kyma-cli) - Kyma CLI documentation, installation and uninstallation commands improved, Kyma certificate as part of the installation command\n- [Logging](#logging) - Loki updated to 0.1.0\n- [Documentation](#documentation) - Configuration documents, troubleshooting document type template, upgrade process documentation\n- [Eventing](#eventing) - Event delivery aligned with the CloudEvents specification 0.3, Kyma subscription cleanup\n- [Service Mesh](#service-mesh) - Disable authentication on selected API paths\n\n> **CAUTION:** Before you upgrade to Kyma 1.3, read the [Migration Guide](https://github.com/kyma-project/kyma/blob/release-1.3/docs/migration-guides/1.2-1.3.md) which describes necessary manual actions required by the Application Connector.\n\n---\n\n## Application Connector\n\n### Fetching API specification secured with Basic Auth or OAuth\n\nApplication Connector supports a variety of authentication methods to allow users to register secured APIs. Now you can also register APIs with a specification URL that requires authentication as the Application Connector can use credentials to fetch the API specification. The supported authentication methods for fetching API specifications are Basic Auth and OAuth. Read [this](https://kyma-project.io/docs/1.3/components/application-connector/#tutorials-register-a-service) document to learn more.   \n\n### Automatic generation of the root Certificate Authority (CA)\n\nApplication Connector serves as a certificate authority that issues client certificates for external systems. Users can provide their own certificates and keys to be used as the root CA. In order to improve security and reduce configuration effort, we automated the certificate and key generation process. From now on, if the user doesn't provide a custom certificate-key pair, the certificate and key are generated automatically. Read [this](https://kyma-project.io/docs/1.3/components/application-connector/#details-application-connector-certificates) document for more information. To learn how the automated certificate generation affects the upgrade process and how to preserve your certificate and key, read the [migration guide](https://github.com/kyma-project/kyma/blob/release-1.3/docs/migration-guides/1.2-1.3.md).\n\n### Additional headers and query parameters stored in a secured way\n\nApplication Connector allows you to enrich each request to the registered API with additional headers and query parameters. Now you can specify a custom list of headers and query parameters that contain sensitive information. The data is stored in a secure manner.\n\n\n## Console\n\n### Less information noise in lambda logs\n\nWe have significantly reduced the noise you have seen so far when inspecting logs from your lambda. By default, we hide health check logs, logs that originate from previous versions of your lambda function, and Istio sidecar logs. Additionally, we added an auto refresh option which automatically pulls new log lines into the UI.\n\n### Easy Namespace labeling and filtering\n\nNow you can manage Namespace labels easily in the Namespace **Details** view in the Console. This will help you better organize your Namespaces using label filter on the **Overview** page. Whenever you apply label filtering in the main Namespace **Overview**, the state of the filter is preserved so that you can stay focused on the Namespaces you have labeled.\n\n### API list streamed using WebSockets\n\nThe list of APIs contains up-to-date data with no need of refreshing the page. All changes in the APIs data are streamed live to the **API** view in the Console.  \n\n### Hide irrelevant navigation nodes\n\nIn case you find some navigation nodes in the Console irrelevant, you can simply ignore them by defining a list of specific navigation nodes or even whole categories that should not show up in the Console UI navigation. Read [this](https://kyma-project.io/docs/1.3/components/console/#configuration-console-chart) document to learn more.\n\n### DevX improvements for the Lambda view\n\nWe have fixed some usability issues that lambda developers were struggling with. Now, after saving changes to your lambda function, you are not redirected to the list of lambdas, but stay on the lambda **Details** view instead.\n\nWhat is more, the issue related to the [environment variables prefix](https://github.com/kyma-project/kyma/issues/3937) is fixed, which results in the same experience when you bind services to lambdas from the **Lambda** view and the **Service Instance** view.\n\n### Console Backend observability improved by integration with OpenTracing and Jaeger\n\nTo make sure that operations and troubleshooting of the Kyma cluster and its Console is easier, in this release we integrated the GraphQL-based backend service with OpenTracing. We also made sure that Jaeger gets proper data about GraphQL requests in a readable way. Now it is easy to check each request's length, failed parts, and logs.\n\n![Console backend](./console-backend.png)\n\n![Console backend 2](./console-backend2.png)\n\n## Core and Supporting\n\n### Documentation component\n\nIn this release, we've worked on a component for documentation that bundles a Markdown renderer and specification renderers, such as OpenAPI or AsyncAPI. The goal is to have a single reusable component that can be used in any context in the Kyma Console and on the `kyma-project.io` website. You can see the progress of this component in the [kyma-incubator](https://github.com/kyma-incubator/documentation-component) organization on GitHub. You can also see the preview of this component in action in the **Documentation** view of the Kyma Console. As you can see in the screenshot, with this component we introduce a right navigation bar for Markdown documentation. This new navigation contains not only a list of documents that you can see on the page, but also a scroll-spy that shows the reader's location on the website.\n\nOur next step is to officially release this component and use it in other Kyma Console areas, such as Service Catalog related views where you can see documentation for different services.  \n\n![Documentation component](./documentation-component.png)\n\n\n## Service Management\n\n### Service Catalog migration from \"API Server\" to \"CRD only\"\n\nNow you can configure Kyma to use the experimental \"CRD only\" mode of our Service Catalog. Read [this](https://kyma-project.io/docs/1.3/components/service-catalog/#details-experimental-features) document to learn how to activate this feature. Moreover, the new mode contains a migration tool that migrates data for you. To learn more about the migration process, read [this](https://github.com/kyma-incubator/service-catalog/blob/crds-migration/docs/migration-apiserver-to-crds.md) document.\n\n>**NOTE:** Before you start the migration, make sure that you performed a full [backup](https://kyma-project.io/docs/1.3/components/backup/) of your cluster. You should also test the procedure on a testing environment first.\n\n\n## Kyma CLI\n\n### Kyma CLI documentation\n\nWe have started documenting Kyma CLI commands, covering the `version` and `install` commands so far. We will continue to document other commands with future releases.\n\n### Installation and uninstallation commands improved\n\nWe improved the `kyma install` and `kyma uninstall` commands with better output in case of errors and timeouts.\n\n### Kyma certificate as part of the installation command\n\nAs part of the `kyma install` command, the certificate used by the installed Kyma cluster is installed to your local certificate trust store. This applies for Windows, Linux and MacOS.\n\n\n## Logging\n\n### Loki updated to 0.1.0\n\nLoki is now updated to the first beta version, which promises a much better stability and feature richness.\n\n\n## Documentation\n\n### Configuration documents\n\nWe have successfully finished writing configuration documents for all Kyma components. If you want to check which parameters from `values.yaml` files of each component’s charts and sub-charts you can configure with overrides, check the **Configuration** section under a particular Kyma component.\n\n### Troubleshooting document type template\n\nIf you need to add troubleshooting documentation to your component, our content guidelines can help you with that. We have published a template for creating Troubleshooting documents. Find more details regarding the new document type [here](https://github.com/kyma-project/community/blob/master/guidelines/templates/resources/troubleshooting.md).\n\n### Upgrade process documentation\n\nUpgrading Kyma to a new version is quick and really simple, and release 1.3 comes with documentation to back this claim. Follow the procedure described in the [Upgrade Kyma](https://kyma-project.io/docs/1.3/root/kyma/#installation-update-kyma) document to quickly migrate to a newer release.\n\n\n## Eventing\n\n### Event delivery aligned with the CloudEvents specification\n\nEvents delivered to the lambda or Serverless now have the context attributes propagated as HTTP headers. Those headers are aligned with the [CloudEvents specification 0.3](https://github.com/cloudevents/spec/blob/master/http-transport-binding.md#31-binary-content-mode). You can use a Cloud SDK in a language of your choice to write the logic of handling Event delivery. For example, [here](https://github.com/cloudevents/sdk-go) you can find an SDK for Go.\n\n### Kyma subscription cleanup\n\nCertain properties which are no longer applicable after Knative migration have been removed.\n\n\n## Service Mesh\n\n### Disable authentication on selected API paths\n\nWith this release, it is possible to expose an API with authentication disabled on certain paths. It is useful for scenarios in which an API hosts public assets, such as schemas or login endpoints.\n\nTo allow disabling authentication on selected paths, there is a new **triggerRule** field in the Api CRD, which contains the `excludedPaths` object that represents the paths on which authentication should be disabled. The rest of the service's paths remain secured, meaning that the authentication is enabled. You can specify a matching method for paths using `exact`,`prefix`,`suffix` and `regex`. Read [this](https://kyma-project.io/docs/1.3/components/api-gateway/#custom-resource-custom-resource) document for more details.\n\n### Known issues\n\nA known issue related to Istio sidecar handling on AKS causes Kubernetes jobs with Istio Proxy sidecar to run endlessly as the sidecar doesn't terminate. As a workaround, disable Istio sidecar injection for all jobs on AKS by adding the `sidecar.istio.io/inject: \"false\"` annotation. To get a better understanding of this problem, read [this](https://github.com/istio/istio/issues/15041) Istio issue and the related discussion. \n","excerpt":"After a short stop in Istanbul, we move forward to Jakarta with the brand new Kyma 1.3 release, which brings you a set of significant improvements in many components, including the Console and Kyma CLI. It also introduces the CloudEvents specification 0.3 for Event delivery and comes with even more useful documents that will guide you through the project. Read on to find out what Kyma 1.3 has to offer.","fields":{"slug":"/blog/2019/7/12/release-notes-13","assetsPath":"/assets/blog-posts/2019-07-12-release-notes-1.3/","date":"July 12, 2019","postInfo":{"fileName":"release-notes-13","year":2019,"month":7,"day":12}},"frontmatter":{"title":"Kyma 1.3 Jakarta","author":{"name":"Klaudia Grzondziel, Technical Writer @Kyma"},"tags":["release-notes"],"type":"release","releaseTag":"1.3.0","redirectFrom":["/blog/release-notes-13"]}},"slidesBanner":{"bannerDuration":5000,"slides":[{"text":"Don't miss the session by Piotr Kopczynski at Helm Summit on September 11 at 15:47.","url":"https://helmsummit2019.sched.com/event/S8sS","startDate":"09/09/2019","endDate":"12/09/2019"}]},"locale":"en"}}}