{"componentChunkName":"component---src-views-blog-single-index-tsx","path":"/blog/2019/7/12/release-notes-13","webpackCompilationHash":"aefb7e842b40c338951f","result":{"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/blog/2019/7/12/release-notes-13","post":{"id":"1267ca79-5465-505c-b637-f87c3af76194","rawMarkdownBody":"\nAfter a short stop in Istanbul, we move forward to Jakarta with the brand new Kyma 1.3 release, which brings you a set of significant improvements in many components, including the Console and Kyma CLI. It also introduces the CloudEvents specification 0.3 for Event delivery and comes with even more useful documents that will guide you through the project. Read on to find out what Kyma 1.3 has to offer.\n\n<!-- overview -->\n\nSee the overview of all changes in this release:\n\n- [Application Connector](#application-connector) - Fetching API specification secured with Basic Auth or OAuth, automatic generation of the root Certificate Authority, additional headers and query parameters stored in a secured way\n- [Console](#console) - Less information noise in lambda logs, easy Namespace labeling and filtering, API list streamed using WebSockets, hide irrelevant navigation nodes, DevX improvements for the **Lambda** view, Console Backend observability improved\n- [Core and Supporting](#core-and-supporting) - Documentation component\n- [Service Management](#service-management) - Service Catalog migration from \"API Server\" to \"CRD only\"\n- [Kyma CLI](#kyma-cli) - Kyma CLI documentation, installation and uninstallation commands improved, Kyma certificate as part of the installation command\n- [Logging](#logging) - Loki updated to 0.1.0\n- [Documentation](#documentation) - Configuration documents, troubleshooting document type template, upgrade process documentation\n- [Eventing](#eventing) - Event delivery aligned with the CloudEvents specification 0.3, Kyma subscription cleanup\n- [Service Mesh](#service-mesh) - Disable authentication on selected API paths\n\n> **CAUTION:** Before you upgrade to Kyma 1.3, read the [Migration Guide](https://github.com/kyma-project/kyma/blob/release-1.3/docs/migration-guides/1.2-1.3.md) which describes necessary manual actions required by the Application Connector.\n\n---\n\n## Application Connector\n\n### Fetching API specification secured with Basic Auth or OAuth\n\nApplication Connector supports a variety of authentication methods to allow users to register secured APIs. Now you can also register APIs with a specification URL that requires authentication as the Application Connector can use credentials to fetch the API specification. The supported authentication methods for fetching API specifications are Basic Auth and OAuth. Read [this](https://kyma-project.io/docs/1.3/components/application-connector/#tutorials-register-a-service) document to learn more.   \n\n### Automatic generation of the root Certificate Authority (CA)\n\nApplication Connector serves as a certificate authority that issues client certificates for external systems. Users can provide their own certificates and keys to be used as the root CA. In order to improve security and reduce configuration effort, we automated the certificate and key generation process. From now on, if the user doesn't provide a custom certificate-key pair, the certificate and key are generated automatically. Read [this](https://kyma-project.io/docs/1.3/components/application-connector/#details-application-connector-certificates) document for more information. To learn how the automated certificate generation affects the upgrade process and how to preserve your certificate and key, read the [migration guide](https://github.com/kyma-project/kyma/blob/release-1.3/docs/migration-guides/1.2-1.3.md).\n\n### Additional headers and query parameters stored in a secured way\n\nApplication Connector allows you to enrich each request to the registered API with additional headers and query parameters. Now you can specify a custom list of headers and query parameters that contain sensitive information. The data is stored in a secure manner.\n\n\n## Console\n\n### Less information noise in lambda logs\n\nWe have significantly reduced the noise you have seen so far when inspecting logs from your lambda. By default, we hide health check logs, logs that originate from previous versions of your lambda function, and Istio sidecar logs. Additionally, we added an auto refresh option which automatically pulls new log lines into the UI.\n\n### Easy Namespace labeling and filtering\n\nNow you can manage Namespace labels easily in the Namespace **Details** view in the Console. This will help you better organize your Namespaces using label filter on the **Overview** page. Whenever you apply label filtering in the main Namespace **Overview**, the state of the filter is preserved so that you can stay focused on the Namespaces you have labeled.\n\n### API list streamed using WebSockets\n\nThe list of APIs contains up-to-date data with no need of refreshing the page. All changes in the APIs data are streamed live to the **API** view in the Console.  \n\n### Hide irrelevant navigation nodes\n\nIn case you find some navigation nodes in the Console irrelevant, you can simply ignore them by defining a list of specific navigation nodes or even whole categories that should not show up in the Console UI navigation. Read [this](https://kyma-project.io/docs/1.3/components/console/#configuration-console-chart) document to learn more.\n\n### DevX improvements for the Lambda view\n\nWe have fixed some usability issues that lambda developers were struggling with. Now, after saving changes to your lambda function, you are not redirected to the list of lambdas, but stay on the lambda **Details** view instead.\n\nWhat is more, the issue related to the [environment variables prefix](https://github.com/kyma-project/kyma/issues/3937) is fixed, which results in the same experience when you bind services to lambdas from the **Lambda** view and the **Service Instance** view.\n\n### Console Backend observability improved by integration with OpenTracing and Jaeger\n\nTo make sure that operations and troubleshooting of the Kyma cluster and its Console is easier, in this release we integrated the GraphQL-based backend service with OpenTracing. We also made sure that Jaeger gets proper data about GraphQL requests in a readable way. Now it is easy to check each request's length, failed parts, and logs.\n\n![Console backend](./console-backend.png)\n\n![Console backend 2](./console-backend2.png)\n\n## Core and Supporting\n\n### Documentation component\n\nIn this release, we've worked on a component for documentation that bundles a Markdown renderer and specification renderers, such as OpenAPI or AsyncAPI. The goal is to have a single reusable component that can be used in any context in the Kyma Console and on the `kyma-project.io` website. You can see the progress of this component in the [kyma-incubator](https://github.com/kyma-incubator/documentation-component) organization on GitHub. You can also see the preview of this component in action in the **Documentation** view of the Kyma Console. As you can see in the screenshot, with this component we introduce a right navigation bar for Markdown documentation. This new navigation contains not only a list of documents that you can see on the page, but also a scroll-spy that shows the reader's location on the website.\n\nOur next step is to officially release this component and use it in other Kyma Console areas, such as Service Catalog related views where you can see documentation for different services.  \n\n![Documentation component](./documentation-component.png)\n\n\n## Service Management\n\n### Service Catalog migration from \"API Server\" to \"CRD only\"\n\nNow you can configure Kyma to use the experimental \"CRD only\" mode of our Service Catalog. Read [this](https://kyma-project.io/docs/1.3/components/service-catalog/#details-experimental-features) document to learn how to activate this feature. Moreover, the new mode contains a migration tool that migrates data for you. To learn more about the migration process, read [this](https://github.com/kyma-incubator/service-catalog/blob/crds-migration/docs/migration-apiserver-to-crds.md) document.\n\n>**NOTE:** Before you start the migration, make sure that you performed a full [backup](https://kyma-project.io/docs/1.3/components/backup/) of your cluster. You should also test the procedure on a testing environment first.\n\n\n## Kyma CLI\n\n### Kyma CLI documentation\n\nWe have started documenting Kyma CLI commands, covering the `version` and `install` commands so far. We will continue to document other commands with future releases.\n\n### Installation and uninstallation commands improved\n\nWe improved the `kyma install` and `kyma uninstall` commands with better output in case of errors and timeouts.\n\n### Kyma certificate as part of the installation command\n\nAs part of the `kyma install` command, the certificate used by the installed Kyma cluster is installed to your local certificate trust store. This applies for Windows, Linux and MacOS.\n\n\n## Logging\n\n### Loki updated to 0.1.0\n\nLoki is now updated to the first beta version, which promises a much better stability and feature richness.\n\n\n## Documentation\n\n### Configuration documents\n\nWe have successfully finished writing configuration documents for all Kyma components. If you want to check which parameters from `values.yaml` files of each component’s charts and sub-charts you can configure with overrides, check the **Configuration** section under a particular Kyma component.\n\n### Troubleshooting document type template\n\nIf you need to add troubleshooting documentation to your component, our content guidelines can help you with that. We have published a template for creating Troubleshooting documents. Find more details regarding the new document type [here](https://github.com/kyma-project/community/blob/master/guidelines/templates/resources/troubleshooting.md).\n\n### Upgrade process documentation\n\nUpgrading Kyma to a new version is quick and really simple, and release 1.3 comes with documentation to back this claim. Follow the procedure described in the [Upgrade Kyma](https://kyma-project.io/docs/1.3/root/kyma/#installation-update-kyma) document to quickly migrate to a newer release.\n\n\n## Eventing\n\n### Event delivery aligned with the CloudEvents specification\n\nEvents delivered to the lambda or Serverless now have the context attributes propagated as HTTP headers. Those headers are aligned with the [CloudEvents specification 0.3](https://github.com/cloudevents/spec/blob/master/http-transport-binding.md#31-binary-content-mode). You can use a Cloud SDK in a language of your choice to write the logic of handling Event delivery. For example, [here](https://github.com/cloudevents/sdk-go) you can find an SDK for Go.\n\n### Kyma subscription cleanup\n\nCertain properties which are no longer applicable after Knative migration have been removed.\n\n\n## Service Mesh\n\n### Disable authentication on selected API paths\n\nWith this release, it is possible to expose an API with authentication disabled on certain paths. It is useful for scenarios in which an API hosts public assets, such as schemas or login endpoints.\n\nTo allow disabling authentication on selected paths, there is a new **triggerRule** field in the Api CRD, which contains the `excludedPaths` object that represents the paths on which authentication should be disabled. The rest of the service's paths remain secured, meaning that the authentication is enabled. You can specify a matching method for paths using `exact`,`prefix`,`suffix` and `regex`. Read [this](https://kyma-project.io/docs/1.3/components/api-gateway/#custom-resource-custom-resource) document for more details.\n\n### Known issues\n\nA known issue related to Istio sidecar handling on AKS causes Kubernetes jobs with Istio Proxy sidecar to run endlessly as the sidecar doesn't terminate. As a workaround, disable Istio sidecar injection for all jobs on AKS by adding the `sidecar.istio.io/inject: \"false\"` annotation. To get a better understanding of this problem, read [this](https://github.com/istio/istio/issues/15041) Istio issue and the related discussion. \n","excerpt":"After a short stop in Istanbul, we move forward to Jakarta with the brand new Kyma 1.3 release, which brings you a set of significant improvements in many components, including the Console and Kyma CLI. It also introduces the CloudEvents specification 0.3 for Event delivery and comes with even more useful documents that will guide you through the project. Read on to find out what Kyma 1.3 has to offer.","fields":{"slug":"/blog/2019/7/12/release-notes-13","assetsPath":"/assets/blog-posts/2019-07-12-release-notes-1.3/","date":"July 12, 2019","postInfo":{"fileName":"release-notes-13","year":2019,"month":7,"day":12}},"frontmatter":{"title":"Kyma 1.3 Jakarta","author":{"name":"Klaudia Grzondziel, Technical Writer @Kyma"},"tags":["release-notes"],"type":"release","releaseTag":"1.3.0","redirectFrom":["/blog/release-notes-13"]}},"assetsPath":"/assets/blog-posts/2019-07-12-release-notes-1.3/","previous":{"id":"e806c68c-9017-5136-849d-798632de9dc2","rawMarkdownBody":"\nCloud-native application development is now a hot topic in the industry. Developers want to use modern languages, write microservices or even serverless functions. They expect high scalability with modern monitoring tools like Prometheus and Grafana. Kubernetes and CNCF landscape projects are no longer perceived as hype for early adopters. This is the mainstream now.\n\nIf you start a new, green field project you are lucky - you can dive into the great variety of tools and frameworks and use them. But how to pick the right tools? At the moment of writing this post, there are 686 projects registered in the [CNCF landscape](https://landscape.cncf.io/).\n\nWe also have the less lucky developers who still have to deal with applications designed when monoliths were cool. What about them? Can they benefit from cloud-native patterns? Yes, they can!\n<!-- overview -->\n\n# Imagine your legacy application\nYou probably have some applications you have to extend or integrate with but you are not happy with that fact. There can be a few reasons for it:\n- It requires writing code in the language you don't know and you want to use only Golang or JavaScript.\n- It is possible to add a new feature to the application but it requires a complex redeployment process which is risky.\n- You just don't want to touch it because it is fragile and adding anything can make it unstable.\n- You want to write an extension which can be scaled independently of the application.\n\n# WordPress as an example\nI prepared some example to help your imagination. The simple scenario with WordPress as a legacy application. Imagine you are running some commerce site and you created a blog on WordPress showing product reviews and tests. Now you want to engage your customers and you enabled comments in your blog posts. Users should see their comments immediately published, but you don't have time to moderate the content. The idea is to publish only positive comments automatically, and put other comments on hold.\n\nYou could use WordPress hook `comment_post` and implement a plugin in PHP. But it won't work for me. I don't know PHP, and my team mates don't either. I would like to use external systems (text analytics, slack, maybe more in the future), and I don't want to deal with secrets and authorization flows in WordPress side. Additionally, I want to utilize all modern DevOps practices and patterns, like [12 Factor App](https://12factor.net). In other words: me and my team want to do cool, cloud native stuff on top of Kubernetes, instead of be WordPress maintainers.\n\nOf course, in this simple scenario microservices, Kubernetes, Service Mesh, and other tools would be overkill but the real-world use cases are more complex, and you can imagine how this initial flow can grow in the future.\n\n# Implementation plan\n\nLet's implement and deploy our example. I will use:\n- A Kubernetes cluster from Google Kubernetes Engine (GKE) to deploy both WordPress and my code\n- Knative eventing and NATS as a messaging middleware to decouple WordPress from my extension\n- Istio Service Mesh together with Prometheus, Grafana, and Jaeger to have monitoring and tracing\n- Kubeless as a serverless engine for my code\n- Grafana and Loki to manage logs\n- Service Catalog, WordPress Connector for Kyma and Kyma Application Broker to bind WordPress API and Events to my code\n\n# Installation\nBased on the above list, you can expect a long installation process but I will use a Kyma operator that will do everything for me. All you need is a Google account and a Google Cloud Platform (GCP) project. If you don't have it yet, create one and Google will give a 12-month free trial with $300 credit to run your cluster.\n\n## Prepare the GKE cluster with Kyma\nFollow the [installation guide](https://kyma-project.io/docs/1.2/root/kyma/#installation-install-kyma-on-a-cluster) for GKE or just execute the following commands, replacing placeholders with proper values:\n\n```bash\n# Set ENV variables. See sample values in comments:\nexport KYMA_VERSION={KYMA_RELEASE_VERSION}      # 1.2.0\nexport CLUSTER_NAME={CLUSTER_NAME_YOU_WANT}     # kyma-cluster\nexport GCP_PROJECT={YOUR_GCP_PROJECT}           # myproject\nexport GCP_ZONE={GCP_ZONE_TO_DEPLOY_TO}         # europe-west1-b\n\n# Create a cluster\ngcloud container --project \"$GCP_PROJECT\" clusters \\\ncreate \"$CLUSTER_NAME\" --zone \"$GCP_ZONE\" \\\n--cluster-version \"1.12\" --machine-type \"n1-standard-4\" \\\n--addons HorizontalPodAutoscaling,HttpLoadBalancing\n\n# Add the current user as an admin\ngcloud container clusters get-credentials $CLUSTER_NAME --zone $GCP_ZONE --project $GCP_PROJECT\nkubectl create clusterrolebinding cluster-admin-binding --clusterrole=cluster-admin --user=$(gcloud config get-value account)\n\n# Install Tiller\nkubectl apply -f https://raw.githubusercontent.com/kyma-project/kyma/$KYMA_VERSION/installation/resources/tiller.yaml\n\n# Install Kyma\nkubectl apply -f https://github.com/kyma-project/kyma/releases/download/$KYMA_VERSION/kyma-installer-cluster.yaml\n\n# Show the Kyma installation progress. Stop the script with `Ctrl+C` when the installation finishes.\nwhile true; do \\\n  kubectl -n default get installation/kyma-installation -o jsonpath=\"{'Status: '}{.status.state}{', description: '}{.status.description}\"; echo; \\\n  sleep 5; \\\ndone\n```\n\n## Access Kyma\n\n> **NOTE:** Follow steps in this section only if you installed Kyma from the instructions in this blog post. If you followed the official Kyma documentation, skip this section as the installation steps cover adding a self-signed certificate and accessing the cluster.\n\nThe simple installation guide we followed uses a self-signed certificate and an `xip.io` domain. Such a certificate will be rejected by your browser so you have to set it as trusted. \n```bash\n# When the installation finishes, add a Kyma self-signed certificate to the trusted certificates (MacOS):\ntmpfile=$(mktemp /tmp/temp-cert.XXXXXX) \\\n&& kubectl get configmap net-global-overrides -n kyma-installer -o jsonpath='{.data.global\\.ingress\\.tlsCrt}' | base64 --decode > $tmpfile \\\n&& sudo security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain $tmpfile \\\n&& rm $tmpfile\n```\n\nRun these commands to display the Console URL, login, and password:\n```bash\necho 'Kyma Console Url:'\necho `kubectl get virtualservice core-console -n kyma-system -o jsonpath='{ .spec.hosts[0] }'`\n\necho 'User admin@kyma.cx, password:'\necho `kubectl get secret admin-user -n kyma-system -o jsonpath=\"{.data.password}\" | base64 --decode`\n```\nYou should get a similar result:\n```console\nKyma Console Url:\nconsole.1.2.3.4.xip.io\nUser admin@kyma.cx, password:\nEca23NyShqwK\n```\nYou can now open the Kyma Console URL in the browser and log in with the provided credentials. \n\n![Kyma Console](./console.png)\n\n## WordPress installation\nIf you already have WordPress installed, you can go to the next step. If not, you can easily deploy WordPress with a few commands:\n```bash\n# Create a Namespace\nkubectl create namespace wordpress\n\n# Deploy WordPress\nkubectl -n wordpress apply -f https://raw.githubusercontent.com/kyma-project/website/master/content/blog-posts/2019-07-08-extend-wordpress/wordpress-deployment.yaml\n```\n\nWait a few seconds for WordPress to start. You can check the status in the **Deployments** section.\n\nWhen the status of all deployments is `RUNNING`, navigate to [https://wordpress.1.2.3.4.xip.io]() replacing the `1.2.3.4` IP with the one for your cluster. Then complete the installation wizard. \n\n## Kyma plugin for WordPress\n\nBefore you install plugins, ensure that you have the proper configuration of Permalinks. Log into WordPress as an admin, go to **Settings** -> **Permalinks**, select the `Post name` option and save your changes.\nDownload the following plugins:\n- [Basic Auth](https://github.com/WP-API/Basic-Auth/archive/master.zip) - for more details go to this [GitHub repository](https://github.com/WP-API/Basic-Auth)\n- [Kyma Connector](https://github.com/kyma-incubator/wordpress-connector/archive/master.zip) - for more details go to this [GitHub repository](https://github.com/kyma-incubator/wordpress-connector)\nIn the left navigation, go to **Plugins** -> **Add New** -> **Upload Plugin**. Choose the Basic Auth and Kyma Connector plugins from your disk to install and activate them.\nGo to **Settings** -> **Kyma Connector**, uncheck the **Verify SSL** option (you need it because the default Kyma installation uses self-signed certificates), provide the username and password you created during the installation, and save your changes. \n\n![Kyma Connector](./kyma-connector.png)\n\n# Connect WordPress to Kyma\n\nIn this step you establish a trusted connection between the WordPress instance and your Kyma cluster, both hosted on the same Kubernetes cluster. You also register WordPress API and WordPress Events in the Service Catalog and enable both in a selected Namespace.\n\nIn the Kyma Console navigate back to the home page, go to **Applications**, and create a new Application called `wordpress`.\n\nOpen it and press **Connect Application**. Copy the connection token URL to the clipboard. Go to the Kyma Connector Settings in WordPress, paste the token URL in the **Kyma Connection** field, and press **Connect**. You should see the success message in WordPress and a new entry inside the **Provided Services & Events** section of the `wordpress` Application in Kyma.\n\n![Application](./application.png)\n\n## Diasable SSL for Kyma->WordPress\n\nWordPress installed in a cluster uses a self-signed SSL certificate. Kyma default settings don't allow for such a connection. You need to explicitly turn it on:\n\n  1. Edit the `wordpress-application-gateway` Deployment in the `kyma-integration` Namespace. Run:\n      ```\n      kubectl -n kyma-integration edit deployment wordpress-application-gateway\n      ```\n  2. Edit the Deployment in Vim. Select `i` to start editing.\n  3. Find the **skipVerify** parameter and change its value to `true`.\n  4. Press **ESC**, type `:wq`, and click **ENTER** to write and quit.\n\nOne command to do it:\n```bash\n# Update kyma installer image to 1.1.0\nkubectl -n kyma-integration \\\n  patch deployment wordpress-application-gateway --type=json \\\n  -p='[{\"op\": \"replace\", \"path\": \"/spec/template/spec/containers/0/args/6\", \"value\": \"--skipVerify=true\"}]'\n```\n>**CAUTION:** The command assumes that **skipVerify** is the argument with the index 6 (0-based).\n\n# Enable WordPress Events and APIs in the default Namespace\n\nThe Kyma Application connectivity can expose APIs and Events (Async API) of Applications in the Service Catalog. To show WordPress in the Service Catalog, first, you need to bind the Application to a selected Namespace. Go to **Applications**, select the `wordpress` Application, press **Create Binding** and select the `default` Namespace. Now go to the `default` Namespace and open the Catalog - you should see WordPress API in the **Services** tab. Open it and have a look at API console and Events specification. We will react on `comment.post.v1` event and interact with `/wp/v2/comments/{id}` API. To make them available in the `default` Namespace click the **Add once** button and create an instance of the WordPress Service Class. Behind the scenes, the Application Connector creates the Application Gateway (a kind of proxy) that forwards requests from bounded services or functions to the WordPress instance. \n\n![Add WordPress Instance](./add-wordpress-instance.png)\n\n# Write your code\nYou did the wiring, so let's write some code. In the `default` Namespace create a new lambda named `review` and paste the following code in the **Settings & Code** editor:\n``` javascript\nconst Sentiment = require('sentiment');\nconst sentiment = new Sentiment();\nconst axios = require(\"axios\");\n\nmodule.exports = {\n    main: async function (event, context) {\n        let status = \"hold\";\n        console.log(\"Event data: %s\",JSON.stringify(event.data));\n        let comment = await getComment(event.data.commentId);\n        console.log(\"Comment: %s\",comment.content.raw);\n        let result = sentiment.analyze(comment.content.raw);\n        console.log(\"Sentiment: %s\",JSON.stringify(result));\n        let score = result.comparative;\n        if (score>0.2) {\n            status = \"approved\"\n        } \n        updateComment(comment.id, status, comment.content.raw, score);\n    }\n};\n\nasync function getComment(id) {\n    let commentUrl = `${process.env.WP_GATEWAY_URL}/wp/v2/comments/${id}?context=edit`\n    let response = await axios.get(commentUrl);\n    return response.data;\n}\n\nasync function updateComment(id, status, comment, score) {\n    let commentUrl = `${process.env.WP_GATEWAY_URL}/wp/v2/comments/${id}`;\n    const update = await axios.post(commentUrl,{status:status, content:comment+\"\\n--\\nscore:\"+score});\n    return update;\n}\n```\n\nIn the **Dependencies** section, add:\n```json\n{\n  \"dependencies\": {\n    \"axios\": \"^0.19.0\",\n    \"sentiment\": \"^5.0.1\"\n  }\n}\n```\nPress **Select Function Trigger**, choose your function which is the `comment.post` Event, and save the function. The trigger is available because you have the WordPress service instance in the `default` Namespace. \n\n# Binding\n\nGo to **Instances** under the **Service Management**, open the WordPress instance in the **Services** tab. Click **Bind Application**, select `review` function, set the **Prefix namespace value** to `WP_`, and confirm.\n\n![Binding](./binding.png)\n\nYou can now open the `review` lambda again and check if there is a new entry in **Service Bindings** section with `WP_GATEWAY_URL` environment variable.\n\n\n# Test it\n\nGo to WordPress main site and open the **Hello World!** blog post. Add the following 2 comments under the blog post:\n- I love it!\n- I hate it!\nGo to the WordPress **Dashboard** and check the comments. You should see that both comments have a score footer with the following sentiment values:\n- `1` for a positive comment\n- `-1` for a negative comment\nThe negative comment is waiting for moderation.\n\n![Comments](./comments.png)\n\n# Explore the benefits\n\nYour code runs using Istio Service Mesh with network secured by mutual TLS. You can see the metrics of your functions, such as latency, responses, errors and memory usage, with one click on Grafana Dashboard. You can trace your requests using Jaeger. And you can scale your functions independently from WordPress.\n\n# Summary\nWhy should you try Kyma? If you start a new project on Kubernetes, you will get carefully selected and best tools from the Cloud Native Landscape, which are already configured and integrated. If you want to move only a part of your project to the cloud and you have to keep legacy applications around, Kyma will help you to build extensions for them using modern tools on top of Kubernetes.\nAlso when you start a new project with a goal that the final solution should be extendable and customizable, considering Kyma to address these challenges from day one would offer benefits. \nPlease remember that Kyma is an open-source project which is actively developed (~80 contributors and ~600 GitHub stars) with the support from such a big company as SAP. \n\n# Next steps\n\nIn the next blog post, I will show you how to use services from cloud providers using the Open Service Broker API. \n","excerpt":"Cloud-native application development is now a hot topic in the industry. Developers want to use modern languages, write microservices or even serverless functions. They expect high scalability with modern monitoring tools like Prometheus and Grafana. Kubernetes and CNCF landscape projects are no longer perceived as hype for early adopters. This is the mainstream now. If you start a new, green field project you are lucky - you can dive into the great variety of tools and frameworks and use them. But how to pick the right tools? At the moment of writing this post, there are 686 projects registered in the CNCF landscape. We also have the less lucky developers who still have to deal with applications designed when monoliths were cool. What about them? Can they benefit from cloud-native patterns? Yes, they can!","fields":{"slug":"/blog/2019/7/8/extend-wordpress","assetsPath":"/assets/blog-posts/2019-07-08-extend-wordpress/","date":"July 08, 2019","postInfo":{"fileName":"extend-wordpress","year":2019,"month":7,"day":8}},"frontmatter":{"title":"Build a cloud-native extension for WordPress","author":{"name":"Piotr Bochynski, Product Owner @Kyma"},"tags":["technology","tutorial"],"type":null,"releaseTag":null,"redirectFrom":["/blog/2019-07-08-extend-wordpress"]}},"next":{"id":"b89e6924-2bcb-5e8f-9894-8aaca053c394","rawMarkdownBody":"\nWith summer in full swing and people enjoying their long-expected holidays, you might've thought that you're not going to get any news from us for some time now. Wrong! We're continuing our travels through the summer holidays season and this time around we're headed to Kyoto. Let's have a look at the new features and improvements planned for the 1.4 release, shall we?   \n\n<!-- overview -->\n\nJapanese are known for their hard work and innovations they introduced to the world of technology over the years. With our newest release sharing its codename with the home of the tech giant that taught us that the princess is always in another castle, we were inspired to focus on innovation and vital improvements. \n\nOn the innovation front, you're getting an OAuth2 server integrated with Kyma. This solution is powered by [Hydra](https://github.com/ory/hydra) and supported by [Oathkeeper](https://github.com/ory/oathkeeper) from [Ory](https://www.ory.sh/). This feature-rich, lightweight (written in Go), and stable open-source solution backed by a huge community is a great fit for Kyma. We're going to make sure it's a good Kubernetes citizen and adds more value to our story and the \"batteries included\" principle we follow.  \n\nWhen it comes to improvements, Kyma 1.4 Kyoto aims to improve on the application registration process. We're going to achieve that by using Compass - a new subproject that is still in the [Kyma Incubator](https://github.com/kyma-incubator/). [Compass](https://github.com/kyma-incubator/compass) consists of components that provide a way to register, group and manage your applications across multiple Kyma runtimes. Using Compass, you can control and monitor your application landscape in one central place. In the new release, it will be available as an experimental feature activated through a feature toggle and will provide a preview of the API and the UI. \n\nRemember \"bundles\"? We decided to rename them to \"addons\" to better reflect the functionality they provide. Kyma 1.4 will come with more flexible addons, with a streamlined publishing process, hosting directly on GitHub, and the ability to enable them in selected Namespaces. \n\nHere are some other things you can expect to see in Kyma 1.4 Kyoto:\n- Improved Namespace view in the UI - better labeling, filtering, and visible health status of deployed workloads\n- Kiali upgraded to the latest stable version and with Single Sign-On enabled\n- Istio upgraded to 1.2.2\n- Backup procedure configurable as part of the installation process\n- Conversion Service and Validation Service for AsyncAPI specifications\n- Experimental standalone Kyma Function controller module with Knative implementation\n\nYou can find all the items planned for the 1.4 release in our [Zenhub](https://app.zenhub.com/workspaces/kyma---all-repositories-5b6d5985084045741e744dea/reports/release?release=5cd88a49145f41296ed5194a). If you want to get an even better look at our plans, be sure to check out the project [roadmap](https://kyma-project.io/roadmap/). \n\nKyma 1.4 Kyoto is scheduled for release on 8.08.2019. Keep an eye out for more Kyma news and updates on our blog. またね! \n","excerpt":"With summer in full swing and people enjoying their long-expected holidays, you might've thought that you're not going to get any news from us for some time now. Wrong! We're continuing our travels through the summer holidays season and this time around we're headed to Kyoto. Let's have a look at the new features and improvements planned for the 1.4 release, shall we?","fields":{"slug":"/blog/2019/7/23/release-14-plan","assetsPath":"/assets/blog-posts/2019-07-23-release-1.4-plan/","date":"July 23, 2019","postInfo":{"fileName":"release-14-plan","year":2019,"month":7,"day":23}},"frontmatter":{"title":"Kyma 1.4 Kyoto scheduled for release on 8.08.2019","author":{"name":"Piotr Bochynski, Product Owner @Kyma"},"tags":["release"],"type":null,"releaseTag":null,"redirectFrom":["/blog/release-14-plan"]}},"slidesBanner":{"bannerDuration":5000,"slides":[{"text":"Don't miss the session by Piotr Kopczynski at Helm Summit on September 11 at 15:47.","url":"https://helmsummit2019.sched.com/event/S8sS","startDate":"09/09/2019","endDate":"12/09/2019"}]},"locale":"en"}}}