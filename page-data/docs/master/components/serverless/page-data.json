{"componentChunkName":"component---src-views-docs-index-tsx","path":"/docs/master/components/serverless","webpackCompilationHash":"aefb7e842b40c338951f","result":{"pageContext":{"isCreatedByStatefulCreatePages":false,"version":"master","versions":{"releases":["0.9"],"prereleases":["1.0"],"branches":["master"]},"content":{"id":"serverless","displayName":"Serverless","description":"Overall documentation for Serverless","type":"components","docs":[{"order":"01-01-serverless","title":"Overview","source":"\nLambdas or lambda functions are small functions that run in Kyma in a cost-efficient and scalable way using JavaScript in Node.js. As the following diagram shows, these functions enable the linking of a wide range of functionalities using Kyma.\n\n![Kyma connected to other products through lambda functions](./assets/kyma_connected.png)\n\n\nThis is an example lambda function:\n\n```\ndef myfunction (event, context):\n  print event\n  return event['data']\n\n```\n\nThe use of lambdas in Kyma addresses several scenarios:  \n\n * Create and manage lambda functions\n * Trigger functions based on business Events\n * Expose functions through HTTP\n * Consume services\n * Provide customers with customized features\n * Version lambda functions\n * Chain multiple functions\n\nLambda functions best serve integration purposes due to their ease of use. Lambda is a quick and ideal solution when the goal is to combine functionalities which are tightly coupled. And, in the context of Kyma, they provide integration with the Event system and Customer Engagement and Commerce tools. Lambda functions are not well-suited to building an application from scratch.\n\nThe Serverless implementation of Kyma is based on [Kubeless](https://github.com/kubeless/kubeless).\n"},{"order":"02-01-serverless","title":"Architecture","source":"\nThe term \"serverless\" refers to an architecture that is Internet-based. Application development that uses serverless technology relies solely on a combination of cloud-based, third-party services, client-side logic, and service-hosted remote procedure calls, also known as \"Functions as a Service\" or FaaS. Developers use lambdas to create this combination. As a result, this combination replaces the common use of a server. In the context of Kyma, lambda functions connect third-party services and Kyma. Developing with this serverless approach reduces the implementation and operation effort of an application to the absolute minimum.\n\n## The Serverless architecture\n\nThe following diagram illustrates a generic serverless implementation.\n\n![General serverless architecture](./assets/serverless_general.png)\n\nThe application flow takes place on the client side. Third parties handle the infrastructural logic. Custom logic can process updates and encapsulate databases. Authentication is an example of custom logic. Third parties can also handle business logic. A hosted database contains read-only data that the client reads. None of this functionality runs on a single, central server. Instead, the client relies on FaaS as its resource.\n\nThe following diagram shows an example of tasks that lambdas can perform in Kyma after a user invokes them.\n\n![Lambdas in Kyma](./assets/lambda_example.png)\n\nFirst, the user invokes the exposed lambda endpoint. Then, the lambda function can carry out a number of tasks, such as:\n\n* Retrieving cart information from Enterprise Commerce\n* Retrieving stock details\n* Updating a database\n\n## Open source components\n\nKyma is comprised of several open source technologies to provide extensive functionality.\n\n### Kubeless\n\nKubeless is the serverless framework integrated into Kyma that allows you to deploy lambda functions. These functions run in Pods inside the Kubeless controller on a node, which can be a virtual or hardware machine.\n\nKubeless also has a command line interface. Use Node.js to create lambda functions.\n\n### Istio\n\nIstio is a third-party component that makes it possible to expose and consume services in Kyma. See the [Istio documentation](https://istio.io) to learn more. Istio helps create a network of deployed services, called a service mesh.\n\nIn Kyma, functions run in Pods. Istio provides a proxy for specified pods that talk to a pilot. The pilot confirms whether access to the pod is permissible as per the request. In the diagram, Pod B requests access to Pod A. Pod A has an Istio proxy that contains a set of instructions on which services can access Pod A. The Istio proxy also notifies Pod A as to whether Pod B is a part of the service mesh. The Istio Proxy gets all of its information from the Pilot.\n\n![Istio architecture](./assets/istio.png)\n\n### NATS\n\nThe Event Bus in Kyma monitors business events and trigger functions based on those events. At the heart of the Event Bus is NATS, an open source, stand-alone messaging system. To learn more about NATS, visit the [NATS website](https://nats.io).\n\nThe following diagram demonstrates the Event Bus architecture.\n\n![Event Bus architecture](./assets/nats.png)\n\nThe Event Bus exposes an HTTP endpoint that the system can consume. An external event, such as a subscription, triggers the Event Bus. A lambda function works with a push notification, and the subscription handling of the Event Bus processes the notification.\n"},{"order":"03-01-custom-resources","title":"Custom Resources","source":"\nKubeless uses CustomResourceDefinitions (CRD) to:\n\n* define the information required for the configuration of custom resources\n* create functions\n* create objects\n\nThe function CRD ships by default with Kubeless.\n\nSee the content of the `kubeless-crd.yaml` file:\n\n````\napiVersion: apiextensions.k8s.io/v1beta1\ndescription: Kubernetes Native Serverless Framework\nkind: CustomResourceDefinition\nmetadata:\n  name: {{ .Values.function.customResourceDefinition.metadata.name | quote }}\n  labels:\n{{ include \"labels.standard\" . | indent 4 }}\nspec:\n  group: {{ .Values.function.customResourceDefinition.spec.group | quote }}\n  names:\n    kind: {{ .Values.function.customResourceDefinition.names.kind | quote }}\n    plural: {{ .Values.function.customResourceDefinition.names.plural | quote }}\n    singular: {{ .Values.function.customResourceDefinition.names.singular | quote }}\n  scope: Namespaced\n  version: v1beta1\n\n````\n\nUse the `.yaml` file to create the custom resource using the following command:\n\n```\nkubectl create -f <filename>\n```\n\nKubeless creates a new namespaced endpoint that you can use to create and manage custom objects. Learn how to use CRDs to create objects in the Kubeless documentation on the [Kubeless website](https://kubeless.io/).\n","type":"Details"},{"order":"03-02-managing-lambdas","title":"Managing Lambdas","source":"\nKubernetes provides Kyma with labels that allow you to arrange lambda functions and group them. Labeling also makes it possible to filter lambdas functions. This functionality is particularly useful when a developer needs to manage a large set of lambda functions.\n\nBehind the scenes, labeling takes place in the form of key value pairs. Here is an example of code that enhances a function:\n\n```\n\"labels\": {\n  \"key1\" : \"value1\",\n  \"key2\" : \"value2\"\n}\n```\n\nFor more details on labels and selectors, visit the [Kubernetes website](https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/).","type":"Details"},{"order":"03-03-programming-model","title":"The Node.js Runtime","source":"\nKyma supports Node.js 6 and 8. The function interface is the same for both versions. It is still best practice to start with Node.js 8, as it supports Promises out of the box. The result is less complicated code.\n\nPlease set the runtime version (Node.js 6 or 8) while creating a function.\n\nIn the next sections, we will describe how the system creates Node.js functions.\n\n### The Handler\n\nThe system uses ```module.exports``` to export Node.js handlers. A handler represents the function code executed during invocation. You have to define the handler using the command line. The Console UI only supports ```main``` as a handler name.\n\n```JavaScript\nmodule.exports = { main: function (event, context) {\n    return\n} }\n```\n\nKyma  supports two execution types: **Request / Response (HTTP)** and **Events**. In both types, a ```return``` identifies a successful execution of the function. For event types, the event is reinjected as long as the execution is not successful. Functions of the Request Response type can return data to the requesting entity. The following three options are available:\n\n| Return                      |Â Content Type     | HTTP Status | Response      |\n| --------------------------- | ---------------- | ----------- | ------------- |\n| ```return```                | none             | 200 (OK)    | -             |\n| ```return \"Hello World!\"``` | none             | 200 (OK)    | Hello World!  |\n| ```return {foo: \"BAR\"}```   | application/json | 200 (OK)    | {\"foo\":\"BAR\"} |\n\nA failing function simply throws an error to tell the event service to reinject the event at a later point. An HTTP-based function returns an HTTP 500 status.\n\n### The Event Object and Context Object\n\nThe function retrieves two parameters: Event and Context.\n\n```yaml\nevent:\n  data:                                         # Request body\n    foo: \"bar\"                                  # The data is parsed as JSON when required\n  extensions:                                   # Optional parameters\n    request:                                    # Reference to the request received\n      query:\n        baz: \"qux\"                              # Query parameters\n      headers:\n        accept: \"application/json\"              # Request headers\n        ...\n      method: \"POST\"                            # HTTP method\n      ...  \n    response: ...                               # Reference to the response to send\n                                                # (specific properties will depend on the function language)\ncontext:\n    function-name: \"pubsub-nodejs\"\n    timeout: \"180\"\n    runtime: \"nodejs6\"\n    memory-limit: \"128M\"\n```\n\nThe Event contains the event payload as well as some request specific metadata. The request and response attributes are primarily responsible for providing control over http behavior.\n\n\n### Advanced Response Handling\n\nTo enable more advanced implementations, the system forwards Node.js Request and Response objects to the function. Access the objects using ```event.extensions.<request|response>```.\n\nIn the example, a custom HTTP response is set.\n\n```JavaScript\nmodule.exports = { main: function (event, context) {\n    console.log(event.extensions.request.originalUrl)\n    event.extensions.response.status(404).send(\"Arg....\")\n} }\n```\n\nThe example code logs the original request url. The response is an HTTP 404. The body is ```Arg....```.\n\n### Logging\n\nLogging is based on standard Node.js functionality. ```console.log(\"Hello\")``` sends \"Hello\" to the logs. As there is no graphical log tool available, use the command ```kubectl``` to display the logs.\n\n```sh\n$ kubectl logs -n {NAMESPACE} -l function=<function> -c {FUNCTION}\n```\n\nThe logs for lambda Pods display the lambda code and the `package.json` file. In the code:\n- `\\n` represents `new line`\n- `\\r` represents `Carriage return`\n- `\\\\` represents `\\`\n\nFor example:\n\n```sh\nLambda Code\nmodule.exports = {\\n main: function (event, context) {\\n        console.log(\"Hello World\")\\n\\n} }\n\nLambda Code dependencies\n{\\n        \"end-of-stream\": \"^1.4.1\",\\n        \"from2\": \"^2.3.0\",\\n        \"lodash\": \"^4.17.5\"\\n}\n```\n","type":"Details"},{"order":"07-01-cli-reference","title":"CLI reference","source":"\nThis section provides you with helpful command line examples used in Kyma.\n\n## Prerequisites\n\n* [kubectl](https://kubernetes.io/docs/tasks/tools/install-kubectl/) 1.10.0\n\nTo develop, deploy, or run functions directly, download these tools additionally:\n\n* [Kubeless CLI](https://github.com/kubeless/kubeless/releases)\n* [Node.js, version 6 or 8](https://nodejs.org/en/download/)\n\n### Set the cluster domain variable\n\nThe commands throughout this guide use URLs that require you to provide the domain of the cluster which you are using. To complete this configuration, set the variable `yourClusterDomain` to the domain of your cluster.\n\nFor example, if your cluster's domain is `demo.cluster.kyma.cx`, run the following command:\n\n   ```bash\n   export yourClusterDomain='demo.cluster.kyma.cx'\n   ```\n\n## Details\n\nUse the command line to create, call, deploy, expose, and bind a function.\n\n### Deploy a function using a yaml file and kubectl\n\nYou can use the Kubeless CLI to deploy functions in Kyma.\n\n```bash\n$ kubectl apply -f https://raw.githubusercontent.com/kyma-project/examples/master/gateway/lambda/deployment.yaml\n```\n\nCheck if the function is available:\n```bash\n$ kubeless function list hello\n```\n### Deploy a function using a JS file and the Kubeless CLI\n\nYou can deploy a function using the Kubernetes and Kubeless CLI. See the following example:\n\n```bash\n$ kubeless function deploy hello --runtime nodejs8 --handler hello.main --from-file https://raw.githubusercontent.com/kyma-project/examples/master/event-subscription/lambda/js/hello-with-data.js --trigger-http\n```\n\n### Call a function using the CLI\n\nUse the CLI to call a function:\n\n```bash\n$ kubeless function call hello\n```\n\n### Expose a function without authentication\n\nUse the CLI to create an API for your function:\n\n```bash\n$ kubectl apply -f https://raw.githubusercontent.com/kyma-project/examples/master/gateway/lambda/api-without-auth.yaml\n```\n\n### Expose a function with authentication enabled\n\nIf your function is deployed to a cluster, run:\n\n```bash\n curl -k https://github.com/kyma-project/examples/blob/master/gateway/lambda/api-with-auth.yaml | sed \"s/.kyma.local/.$yourClusterDomain/\" | kubectl apply -f -\n```\n\n\nIf Kyma is running locally, add `hello.kyma.local` mapped to `minikube ip` to `/etc/hosts`.\n\n```bash\n$ echo \"$(minikube ip) hello.kyma.local\" | sudo tee -a /etc/hosts\n```\n\nCreate the API for your function:\n\n```bash\nkubectl apply -f https://github.com/kyma-project/examples/blob/master/gateway/lambda/api-with-auth.yaml\n```\n\n### Bind a function to events\nYou can bind the function to Kyma and to third-party services. For details, refer to the Service Catalog-related documentation.\n"}]},"navigation":{"root":[{"displayName":"Kyma","id":"kyma"}],"components":[{"displayName":"Security","id":"security"},{"displayName":"Service Catalog","id":"service-catalog"},{"displayName":"Helm Broker","id":"helm-broker"},{"displayName":"Application Connector","id":"application-connector"},{"displayName":"Event Bus","id":"event-bus"},{"displayName":"Service Mesh","id":"service-mesh"},{"displayName":"Serverless","id":"serverless"},{"displayName":"Monitoring","id":"monitoring"},{"displayName":"Tracing","id":"tracing"},{"displayName":"API Gateway","id":"api-gateway"},{"displayName":"Logging","id":"logging"},{"displayName":"Backup","id":"backup"},{"displayName":"Console","id":"console"},{"displayName":"Asset Store","id":"asset-store"},{"displayName":"Headless CMS","id":"headless-cms"}]},"manifest":{"root":[{"displayName":"Kyma","id":"kyma"}],"components":[{"displayName":"Security","id":"security"},{"displayName":"Service Catalog","id":"service-catalog"},{"displayName":"Helm Broker","id":"helm-broker"},{"displayName":"Application Connector","id":"application-connector"},{"displayName":"Event Bus","id":"event-bus"},{"displayName":"Service Mesh","id":"service-mesh"},{"displayName":"Serverless","id":"serverless"},{"displayName":"Monitoring","id":"monitoring"},{"displayName":"Tracing","id":"tracing"},{"displayName":"API Gateway","id":"api-gateway"},{"displayName":"Logging","id":"logging"},{"displayName":"Backup","id":"backup"},{"displayName":"Console","id":"console"},{"displayName":"Asset Store","id":"asset-store"},{"displayName":"Headless CMS","id":"headless-cms"}]},"assetsPath":"/assets/docs/master/serverless/docs/assets/","docsType":"components","topic":"serverless","slidesBanner":{"bannerDuration":5000,"slides":[{"text":"Don't miss the session by Piotr Kopczynski at Helm Summit on September 11 at 15:47.","url":"https://helmsummit2019.sched.com/event/S8sS","startDate":"09/09/2019","endDate":"12/09/2019"}]},"locale":"en"}}}