{"componentChunkName":"component---src-views-docs-index-tsx","path":"/docs/0.9/components/event-bus","webpackCompilationHash":"aefb7e842b40c338951f","result":{"pageContext":{"isCreatedByStatefulCreatePages":false,"version":"0.9","versions":{"releases":["0.9"],"prereleases":["1.0"],"branches":["master"]},"content":{"id":"event-bus","displayName":"Event Bus","description":"Overall documentation for Event Bus","type":"components","docs":[{"order":"01-01-event-bus","title":"Overview","source":"\nKyma Event Bus enables the integration of various external solutions with Kyma. The integration is achieved using the `publish-subscribe` messaging pattern that allows Kyma to receive business Events from different solutions, enrich them, and trigger business flows using lambdas or services defined in Kyma.\n\nTo learn how to write an HTTP service or lambda in Kyma, and handle the Event Bus published Events, check [this](#details-service-programming-model) document.\n\n> **NOTE:** The Event Bus is based on the [NATS Streaming](https://github.com/nats-io/nats-streaming-server/releases) open source log-based streaming system for cloud-native applications, which is a brokered messaging middleware. The Event Bus provides **at-least-once** delivery guarantees.\n"},{"order":"02-01-event-bus","title":"Architecture","source":"\nSee the diagram and steps for an overview of the basic Event Bus flow:\n\n![Event Bus architecture](./assets/event-bus-architecture.png)\n\n## Event flow\n\n1. The external solution integrated with Kyma makes a REST API call to the Application Connector to indicate that a new Event is available.\n\n2. The Application Connector enriches the Event with the details of its source.\n\n> **NOTE:** There is always one dedicated instance of the Application Connector for every instance of an external solution connected to Kyma.\n\n3. The Application Connector makes a REST API call to `publish` and sends the enriched Event.\n\n4. `publish` saves the information in the NATS Streaming database.\n\n5. NATS Streaming stores the Event details in the Persistence storage volume to ensure the data is not lost if the NATS Streaming crashes.\n\n6. If the Subscription [validation process](#architecture-architecture-event-validation) completes successfully, `push` consumes the Event from NATS Streaming.\n\n7. `push` delivers the Event to the lambda or the service.\n\n## Event validation\n\nThe Event Bus performs Event validation before it allows Event consumption.\n\n### Validation details\n\nWhen you create a lambda or a service to perform a given business functionality, you also need to define which Events trigger it. Define triggers by creating the Subscription custom resource in which you register with the Event Bus to forward the Events of a particular type, such as `order-created`, to your lambda or a service. Whenever the `order-created` Event comes in, the Event Bus consumes it by saving it in NATS Streaming and Persistence, and sends it to the correct receiver specified in the Subscription definition.\n\n> **NOTE:** The Event Bus creates a separate Event Trigger for each Subscription.\n\nBefore the Event Bus forwards the Event to the receiver, the sub-validator performs a security check to verify the permissions for this Event in a given Namespace. It reads all new Subscription resources and refers to the EventActivation resource to check whether a particular Event type is enabled in a given Namespace. If the Event is enabled for an Namespace, it updates the Subscription resource with the information. Based on the information, `push` sends the Event to the lambda or the service.\n\n### Validation flow\n\nSee the diagram and a step-by-step description of the Event verification process.\n\n![Event validation process](./assets/event-validation.png)\n\n1. The Kyma user defines a lambda or a service.\n2. The Kyma user creates a Subscription custom resource.\n3. The sub-validator reads the new Subscription.\n4. The sub-validator refers to the EventActivation resource to check if the Event in the Subscription is activated for the given Namespace.\n5. The sub-validator updates the Subscription resource accordingly.\n"},{"order":"03-01-concepts","title":"Basic concepts","source":"\nThe following resources are involved in Event transfer and validation in Kyma:\n\n* **EventActivation** is a custom resource controller that the Application Broker (AB) creates. Its purpose is to define Event availability in a given Namespace.\n\n* **NATS Streaming** is an open source, log-based streaming system that serves as a database allowing the Event Bus to store and transfer the Events on a large scale.\n\n* **Persistence** is a back-end storage volume for NATS Streaming that stores Events. When the Event flow fails, the Event Bus can resume the process using the Events saved in Persistence.\n\n* **Publish** is an internal Event Bus service that transfers the enriched Event from a given external solution to NATS Streaming.\n\n* **Push** is an application responsible for receiving Events from NATS Streaming in the Event Bus. Additionally, it delivers the validated Events to the lambda or the service, following the trigger from the Subscription custom resource. The Events are delivered to the lambda or the service through the Envoy proxy sidecar with mTLS enabled.\n\n* **Subscription** is a custom resource that the lambda or service creator defines to subscribe a given lambda or a service to particular types of Events.\n\n* **Sub-validator** is a Kubernetes deployment. It updates the status of the Subscription custom resource with the EventActivation status. Depending on the status, `push` starts or stops delivering Events to the lambda or the service webhook.\n","type":"Details"},{"order":"03-02-event-flow-requirements","title":"Event flow requirements","source":"\nThe Event Bus enables a successful flow of Events in Kyma when:\n\n- You have enabled the [EventActivation](/docs/0.9/components/event-bus#details-basic-concepts) controller.\n- You have created a [Subscription](/docs/0.9/components/event-bus#custom-resource-subscription) custom resource and registered the webhook for a lambda or service to consume the Events.\n- The Events are [published](#details-event-flow-requirements-event-publishing).\n\n\n### Activate Events\n\nEnable the EventActivation controller to ensure the Event flow between the Namespace and the Application (App). \nAlternatively, [bind](/docs/0.9/components/application-connector#tutorials-bind-an-application-to-a-namespace) the App to the Namespace and create a Service Instance.\n\nThe diagram shows you the Event activation flow for a given Namespace.\n\n![EventActivation.png](./assets/event-activation.svg)\n\nThe App sends the Events to the Event Bus and uses the EventApplication controller to ensure the Namespace receives the Events.  If you define a lambda in the `prod123` Namespace, it receives the **order.created** Event from the App through the Event Bus. The lambda in the `test123` Namespace does not receive any Events, since you have not enabled the EventActivation controller.\n\n\n### Consume Events\n\nConfigure lambdas and services to use the `push` command for consuming Events coming from the App. To make sure the lambda or the service receive the Events, register a webhook for them by creating a [Subscription custom resource](/docs/0.9/components/event-bus#custom-resource-subscription). \n\n### Publish Events\n\nMake sure that the external solution sends Events to Kyma. For details of the Event flow, see [this](/docs/0.9/components/event-bus#architecture-architecture) document.\n","type":"Details"},{"order":"03-03-service-programming-model","title":"Service Programming Model","source":"\nYou can configure a microservice deployed in Kyma to receive Events from the Event Bus by creating a Subscription custom resource.\n\n## Event Delivery\n\nThe Event is delivered as an `HTTP POST` request. Event Metadata is a part of an HTTP request Headers. Event Payload is the body of the request.\n\n![TEST](./assets/service-programming-model.png)\n\nThe Event Delivery workflow is as follows:\n\n1. The Event is published to the Kyma Event Bus from an external system instance in a bound Application.\n2. The Event Bus checks for the Event subscription and activation. It creates an `HTTP POST` request using Event Payload and Metadata.\n3. The Service receives the `HTTP POST` request. The Event Metadata is represented in the `HTTP Request Headers` request and the Event Payload is represented in the `HTTP Request Body`.\n\n## Event Metadata\n\nThe following HTTP Headers provide information about the Event Metadata.\n\n|Header| Description|\n|------|--------|\n| **ce-event-id** | Business Event's ID delivered to the microservice. |\n| **ce-event-time** | Business Event's time delivered to the microservice. |\n| **ce-event-type** | Business Event's type delivered to the microservice. |\n| **ce-event-type-version** | Business Event's version delivered to the microservice. |\n| **ce-source-id** | Identifies the origin of events. This can be an external solution or a defined identifier for internally generated events. |\n| **kyma-subscription** | Subscription name defined in the subscription contract, or in a CRD. This business Event is published to its subscribers. |\n| **x-b3-flags** | Header used by the Zipkin tracer in Envoy. It encodes one or more options. See more on Zipkin tracing [here](https://github.com/openzipkin/b3-propagation). |\n| **x-b3-parentspanid** | Header used by the Zipkin tracer in Envoy. The **ParentSpanId** is 64-bit in length and indicates the position of the parent operation in the trace tree. When the span is the root of the trace tree, the **ParentSpanId** is absent. |\n| **x-b3-sampled** | Header used by the Zipkin tracer in Envoy. When the **Sampled** flag is either not specified or set to `1`, the span is reported to the tracing system. Once **Sampled** is set to `0` or `1`, the same value should be consistently sent downstream. |\n| **x-b3-spanid** | Header used by the Zipkin tracer in Envoy. The **SpanId** is 64-bit in length and indicates the position of the current operation in the trace tree. The value should not be interpreted. It may or may not be derived from the value of the **TraceId**. |\n| **x-b3-traceid** | Header used by the Zipkin tracer in Envoy. The **TraceId** is 64-bit in length and indicates the overall ID of the trace. Every span in a trace shares this ID. |\n| **x-request-id** | Randomly generated ID which identifies the HTTP request delivering the business Event. |\n| **x-envoy-decorator-operation** | If this header is present in Ingress requests, its value overrides any locally defined operation (span) name on the server span generated by the tracing mechanism. If this header is present in an Egress response, its value overrides any locally defined operation (span) name on the client span. |\n| **x-envoy-expected-rq-timeout-ms** | Time in milliseconds in which the router expects the request to be completed. Envoy sets this header so that the upstream host receiving the request can make decisions based on the request timeout. It is set on internal requests and is either taken from the **x-envoy-upstream-rq-timeout-ms** header or from the route timeout. |\n| **x-istio-attributes** | Istio-specific metadata. |\n\n## Event Payload\n\nThe Event Payload is delivered as the body of the HTTP Request in JSON format. The JSON schema is available in the Service Catalog in the registered service for the remote Events.\n\n## Event Payload Example\n\nIn this example, you write a service for an `order.created` Event published by the external solution service. The published Event schema looks as follows:\n\n```json\n{\n  \"example\": {\n    \"orderCode\": \"4caad296-e0c5-491e-98ac-0ed118f9474e\"\n  },\n  \"properties\": {\n    \"orderCode\": {\n      \"description\": \"Resource identifier\",\n      \"title\": \"OrderCode\",\n      \"type\": \"string\"\n    }\n  },\n  \"type\": \"object\"\n}\n```\n\nThe HTTP POST request payload is a JSON object:\n\n```json\n{\"orderCode\": \"4caad296-e0c5-491e-98ac-0ed118f9474e\"}\n```\n\n## Successful Delivery\n\nA message delivered to a subscriber is considered successfully consumed if the service's HTTP response status code is\n`2xx`, for example:\n```json\n{\n    \"event-id\": \"22ae22a4-f5b7-4fa1-ada9-558a10a96f3d\",\n    \"status\": \"published\",\n    \"reason\": \"Message successfully published to the channel\"\n}\n```\nIf the status code is not `2xx` (< `200` or >= `300`), it means that the message was not consumed successfully and\nthat the Event Bus will try to deliver it again. This implies **At-least-once** delivery guarantee.\n>**NOTE**: If there were no subscriptions or consumers to this `event-type`, the message is ignored and the response\nwill look like this:\n```json\n{\n    \"event-id\": \"22ae22a4-f5b7-4fa1-ada9-558a10a96f3d\",\n    \"status\": \"ignored\",\n    \"reason\": \"Event was ignored as there are no subscriptions or consumers configured for this event\"\n}\n```\n\n## Event Subscription Service Example\n\nRefer to [this](https://github.com/kyma-project/examples/tree/master/event-subscription/service) example to find a complete scenario for implementing a subscriber service to a business Event.\n","type":"Details"},{"order":"03-04-troubleshooting","title":"Troubleshooting","source":"\nIn some cases, you can encounter some problems related to eventing. This\ndocument introduces several ways to troubleshoot such problems.\n\n## General Troubleshooting Guidelines\n\n* If the lambda or the service does not receive any Events, check the following:\n  - Confirm that the EventActivation custom resource is in place.\n  - Ensure that the webhook defined for the lambda or the service is up and\n    running.\n  - Make sure the Events are published.\n\n* If errors appear while sending Events:\n  - Check if the `publish` application is up and running.\n  - Make sure that NATS Streaming is up and running.\n\n If these general guidelines do not help, go to the next section of this\n document.\n\n## Search by tags\nYou can search traces using tags. Tags are key-value pairs configured for each service.\n\nSee the full list of tags for a service from the details of that service's span.\n\nFor example, these are the tags for the `publish-service`:\n* `event-type`\n* `event-type-ver`\n* `event-id`\n* `source-id`\n\nTo search the traces, you can use either a single tag such as `event-type=\"order.created\"`, or multiple tags such as `event-type=\"order.created\" event-type-ver=\"v1\"`.\n\n## Troubleshooting using Kyma Tracing\n\nTracing allows you to troubleshoot different problems that you might encounter\nwhile using Kyma. Understanding the common scenarios and how the expected traces\nlook like gives you a better grasp on how to quickly use Kyma tracing\ncapabilities to pinpoint the root cause. See the exemplary scenario for\nreference.\n\n### Scenario: I have no microservice or lambda configured to receive an Event\n\nThis scenario assumes that there is an Event sent from the external system but\nthere is no lambda or microservice configured with the Event trigger.\n\nAs a result, only the trace for the `publish` and initial services are visible.\n\n![](./assets/troubleshoot-only-publish-overview.png)\n\nIn the trace details, you can see the tags for the `publish-service`.\n\n![](./assets/troubleshoot-only-publish-detail.png)\n\n### Scenario: Configured microservice or lambda returns an error\n\nThis scenario assumes that there is a microservice or lambda configured to recieve\nthe event trigger. However, due to a bug in the code, the microservice or lambda \nfailed to process the Event.\n\nAs a result, you can see the `webhook`, `push`, and `name-of-lambda` services in the trace and they are marked with error.\n\n![](./assets/troubleshoot-error-in-lambda.png)\n\nTo see the error details, click on one of the service spans. For example, choose the span for the `push` service.\n![](./assets/troubleshoot-error-in-lambda-details.png)\n\nSince the Event Bus keeps on retrying to deliver the Event until it is successful, you \ncan see multiple spans for the `webhook-service`.\n\n![](./assets/troubleshoot-error-multiple-spans.png)\n","type":"Details"},{"order":"03-05-subscription-updates","title":"Subscription updates","source":"\nTo update the subscription CRD, run this command:\n\n`kubectl edit crd subscriptions.eventing.kyma-project.io`\n\nThe Event Bus reacts to the changes in subscription CRD, and updates the corresponding NATS-Streaming subscription accordingly.\n\n>**NOTE:** The current subscription update mechanism recreates a subscription with new specifications. This may result in the loss of messages delivered during the recreation process.\n","type":"Details"},{"order":"06-01-subscription","title":"Subscription","source":"\nThe `subscriptions.eventing.kyma-project.io` CustomResourceDefinition (CRD) is a detailed description of the kind of data and the format used to create an Event trigger for a lambda or microservice in Kyma. After creating a new custom resource, the Event trigger is registered in the Event Bus and Events are delivered to the endpoint specified in the custom resource.\n\nTo get the up-to-date CRD and show the output in the `yaml` format, run this command:\n\n```\nkubectl get crd subscriptions.eventing.kyma-project.io -o yaml\n```\n\n## Sample custom resource\n\nThis is a sample resource that creates an `order.created` Event trigger for a lambda.\n\n```yaml\napiVersion: eventing.kyma-project.io/v1alpha1\nkind: Subscription\nmetadata:\n  name: hello-with-data-subscription\n  labels:\n    example: event-bus-lambda-subscription\nspec:\n  endpoint: http://hello-with-data.{NAMESPACE}:8080/\n  push_request_timeout_ms: 2000\n  max_inflight: 400\n  include_subscription_name_header: true\n  event_type: order.created\n  event_type_version: v1\n  source_id: stage.commerce.kyma.local\n```\n\n## Custom resource parameters\n\nThis table lists all the possible parameters of a given resource together with their descriptions:\n\n| Parameter                                 | Mandatory | Description                                                                                                                |\n|:-----------------------------------------:|:---------:|:---------------------------------------------------------------------------------------------------------------------------|\n| **metadata.name**                         | **YES**   | Specifies the name of the CR.                                                                                              |\n| **spec.endpoint**                         | **YES**   | The HTTP endpoint to which events are delivered as a POST request.                                                         |\n| **spec.push_request_timeout_ms**          | **YES**   | The HTTP request timeout. Once the timeout expires, the Event Bus retries to deliver the Event. Setting the **minimum** parameter to `0` applies the default value of `1000ms`.                                   |\n| **spec.max_inflight**                     | **YES**   | The maximum number of Events delivered concurrently. The final value is the **max_inflight** value multiplied by the number of  `push` applications.                                                          |\n| **spec.include_subscription_name_header** | **YES**   | The boolean flag indicating if the name of the Subscription should be included in the HTTP headers while delivering the Event. |\n| **spec.event_type**                       | **YES**   | The Event type to which the Event trigger is registered. For example, **order.created**.                                                                 |\n| **spec.event_type_version**               | **YES**   | The version of the Event type.                                                                                             |\n| **spec.source_id**                        | **YES**   | Identifies the origin of events. This can be an external solution or a defined identifier for internally generated events.|\n","type":"Custom Resource"},{"order":"07-01-cli-reference","title":"CLI reference","source":"\n Management of the Event Bus is based on the custom resources specifically defined for Kyma. Manage all of these resources through [kubectl](https://kubernetes.io/docs/reference/kubectl/overview/).\n\n## Details\n\nThis section describes the resource names to use in kubectl, the command syntax, and examples of use.\n\n### Resource types\n\nEvent Bus operations use the following resources:\n\n| Singular name        | Plural name         |\n| -------------------- | ------------------- |\n| subscription         | subscriptions       |\n\n### Syntax\n\nFollow the kubectl syntax, `kubectl {command} {type} {name} {flags}`, where:\n\n* {command} is any command, such as `describe`.\n* {type} is a resource type, such as `clusterserviceclass`.\n* {name} is the name of a given resource type. Use {name} to make the command return the details of a given resource.\n* {flags} specifies the scope of the information. For example, use flags to define the Namespace from which to get the information.\n\n### Examples\n\nThe following examples show how to create new Subscriptions, list them, and obtain detailed information on their statuses.\n\n* Create a new Subscription directly from the terminal:\n\n```\n   cat <<EOF | kubectl create -f -\n   apiVersion: eventing.kyma-project.io/v1alpha1\n   kind: Subscription\n   metadata:\n     name: my-subscription\n     namespace: stage\n   spec:\n     endpoint: http://testjs.default:8080/\n     push_request_timeout_ms: 2000\n     max_inflight: 400\n     include_subscription_name_header: true\n     event_type: order_created\n     event_type_version: v1\n     source_id: stage.commerce.kyma.local\nEOF\n```\n\n* Get the list of all Subscriptions:\n\n```\nkubectl get subscription --all-namespaces\n```\n\n* Get the list of all Subscriptions with detailed information on the Subscription status:\n\n```\nkubectl get subscriptions -n stage -o=custom-columns=NAME:.metadata.name,STATUS:.status.conditions[*].status,STATUS\\ TYPE:.status.conditions[*].type\n```\n"}]},"navigation":{"root":[{"displayName":"Kyma","id":"kyma"}],"components":[{"displayName":"Security","id":"security"},{"displayName":"Service Catalog","id":"service-catalog"},{"displayName":"Helm Broker","id":"helm-broker"},{"displayName":"Application Connector","id":"application-connector"},{"displayName":"Event Bus","id":"event-bus"},{"displayName":"Service Mesh","id":"service-mesh"},{"displayName":"Serverless","id":"serverless"},{"displayName":"Monitoring","id":"monitoring"},{"displayName":"Tracing","id":"tracing"},{"displayName":"API Gateway","id":"api-gateway"},{"displayName":"Logging","id":"logging"},{"displayName":"Backup","id":"backup"},{"displayName":"Console","id":"console"},{"displayName":"Asset Store","id":"asset-store"},{"displayName":"Headless CMS","id":"headless-cms"}]},"manifest":{"root":[{"displayName":"Kyma","id":"kyma"}],"components":[{"displayName":"Security","id":"security"},{"displayName":"Service Catalog","id":"service-catalog"},{"displayName":"Helm Broker","id":"helm-broker"},{"displayName":"Application Connector","id":"application-connector"},{"displayName":"Event Bus","id":"event-bus"},{"displayName":"Service Mesh","id":"service-mesh"},{"displayName":"Serverless","id":"serverless"},{"displayName":"Monitoring","id":"monitoring"},{"displayName":"Tracing","id":"tracing"},{"displayName":"API Gateway","id":"api-gateway"},{"displayName":"Logging","id":"logging"},{"displayName":"Backup","id":"backup"},{"displayName":"Console","id":"console"},{"displayName":"Asset Store","id":"asset-store"},{"displayName":"Headless CMS","id":"headless-cms"}]},"assetsPath":"/assets/docs/0.9/event-bus/docs/assets/","docsType":"components","topic":"event-bus","slidesBanner":{"bannerDuration":5000,"slides":[{"text":"Don't miss the session by Piotr Kopczynski at Helm Summit on September 11 at 15:47.","url":"https://helmsummit2019.sched.com/event/S8sS","startDate":"09/09/2019","endDate":"12/09/2019"}]},"locale":"en"}}}